{
    "docs": [
        {
            "location": "/", 
            "text": "Portability Across DOE Office of Science HPC Facilities\n\n\nAs the HPC community prepares for exascale and the semiconductor industry approaches the end of Moore's Law in terms of transistor size, we have entered a \nperiod of time of increased diversity in computer architecture for HPC with relatively new designs joining mature x86, DDR standard processor and memory \ntechnologies. These technologies include GPUs, Many Core Processors, ARM, FPGA and ASICs as well as new memory technology in the form of High Bandwidth \nMemory (HBM) often incorporated on the processor die as well as Non-Volatile memory (NVRAM) and Solid-State Disk (SSD) technology for accelerated IO. \n\n\nThe DOE Office of Science operates three world leading HPC facilities located at the Argonne Leadership Computing Facility (ALCF), National Energy Research \nScienctifc Computing Center (NERSC) at Lawrence Berkeley Lab and the Oak Ridge Leadership Computing Center (OLCF). These facilities field three of the most \npowerful supercomputers in world used by scientists throughout the DOE Office of Science and the world solving a \nnumber of important science problem in domains from materials science and chemistry to nuclear, particle and astrophysics. \n\n\nThese facilities have begun the transition for DOE users to energy-efficient like architectures. The facilities are currently fielding \nsystems with two-distinct \"pre-exascale\" like architectures that we discuss in detail on the subsequent pages: \n\n\n\n\n\n\n\n\nSystem\n\n\nTitan\n\n\n\n\n\n\n\n\n\n\nLocation\n\n\nOLCF\n\n\n\n\n\n\nArchitecture\n\n\nCPU + NVIDIA GPU\n\n\n\n\n\n\nScale\n\n\n18,688 Nodes\n\n\n\n\n\n\nPicture\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSystem\n\n\nCori\n\n\n\n\n\n\n\n\n\n\nLocation\n\n\nNERSC\n\n\n\n\n\n\nArchitecture\n\n\nXeon-Phi\n\n\n\n\n\n\nScale\n\n\n9688 Nodes\n\n\n\n\n\n\nNotes\n\n\nSSD Burst-Buffer IO layer\n\n\n\n\n\n\nPicture\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSystem\n\n\nTheta\n\n\n\n\n\n\n\n\n\n\nLocation\n\n\nALCF\n\n\n\n\n\n\nArchitecture\n\n\nXeon-Phi\n\n\n\n\n\n\nScale\n\n\n3624 Nodes\n\n\n\n\n\n\nPicture\n\n\n\n\n\n\n\n\n\n\nThe two processor architectures deployed on these systems are the CPU+NVidia GPU hybrid architecture on Titan and the \"self-hosted\" Xeon-Phi processors \n(code named \"Knights Landing\"). These two architectures, while seemingly quite different at first appearance, have a number of similarities that we believe \nrepresent general trends in exascale like architectures:\n\n\n\n\nIncrease parallelism (Cores, Threads, Warps/Blocks)\n\n\nVectorization (AVX512, 32 Wide Warps)\n\n\nSmall Amount High-bandwidth Coupled with Large Amounts of Traditional DDR\n\n\n\n\nWhile the details of the architectures are distinct and vendor specific programming libraries/languages (CUDA, AVX512 Intrinsics etc.) exist to address \nspecific architecture features; the commonalities are significant that a number of portable programming approaches exist for writing code that supports both \narchitectures. \n\n\nThis living website is intended to be a guide for applications teams targetting systems at multiple DOE office of science facilities. In the below pages, we \ndiscuss in detail the differences between the systems, the software environment and job-submission process. We discuss how to define and measure performacne \nportability and we provide recommendations and case studies for the most promising performance-portability pogramming approaches.\n\n\nAs an additional valuable resource, the Centers of Excellence from DOE facilities in both the Office of Science and the National Nuclear Security Agency \n(NNSA) have coordinated an annual meeting with a detailed report of findings available \nhere\n).", 
            "title": "Introduction"
        }, 
        {
            "location": "/#portability-across-doe-office-of-science-hpc-facilities", 
            "text": "As the HPC community prepares for exascale and the semiconductor industry approaches the end of Moore's Law in terms of transistor size, we have entered a \nperiod of time of increased diversity in computer architecture for HPC with relatively new designs joining mature x86, DDR standard processor and memory \ntechnologies. These technologies include GPUs, Many Core Processors, ARM, FPGA and ASICs as well as new memory technology in the form of High Bandwidth \nMemory (HBM) often incorporated on the processor die as well as Non-Volatile memory (NVRAM) and Solid-State Disk (SSD) technology for accelerated IO.   The DOE Office of Science operates three world leading HPC facilities located at the Argonne Leadership Computing Facility (ALCF), National Energy Research \nScienctifc Computing Center (NERSC) at Lawrence Berkeley Lab and the Oak Ridge Leadership Computing Center (OLCF). These facilities field three of the most \npowerful supercomputers in world used by scientists throughout the DOE Office of Science and the world solving a \nnumber of important science problem in domains from materials science and chemistry to nuclear, particle and astrophysics.   These facilities have begun the transition for DOE users to energy-efficient like architectures. The facilities are currently fielding \nsystems with two-distinct \"pre-exascale\" like architectures that we discuss in detail on the subsequent pages:      System  Titan      Location  OLCF    Architecture  CPU + NVIDIA GPU    Scale  18,688 Nodes    Picture         System  Cori      Location  NERSC    Architecture  Xeon-Phi    Scale  9688 Nodes    Notes  SSD Burst-Buffer IO layer    Picture         System  Theta      Location  ALCF    Architecture  Xeon-Phi    Scale  3624 Nodes    Picture      The two processor architectures deployed on these systems are the CPU+NVidia GPU hybrid architecture on Titan and the \"self-hosted\" Xeon-Phi processors \n(code named \"Knights Landing\"). These two architectures, while seemingly quite different at first appearance, have a number of similarities that we believe \nrepresent general trends in exascale like architectures:   Increase parallelism (Cores, Threads, Warps/Blocks)  Vectorization (AVX512, 32 Wide Warps)  Small Amount High-bandwidth Coupled with Large Amounts of Traditional DDR   While the details of the architectures are distinct and vendor specific programming libraries/languages (CUDA, AVX512 Intrinsics etc.) exist to address \nspecific architecture features; the commonalities are significant that a number of portable programming approaches exist for writing code that supports both \narchitectures.   This living website is intended to be a guide for applications teams targetting systems at multiple DOE office of science facilities. In the below pages, we \ndiscuss in detail the differences between the systems, the software environment and job-submission process. We discuss how to define and measure performacne \nportability and we provide recommendations and case studies for the most promising performance-portability pogramming approaches.  As an additional valuable resource, the Centers of Excellence from DOE facilities in both the Office of Science and the National Nuclear Security Agency \n(NNSA) have coordinated an annual meeting with a detailed report of findings available  here ).", 
            "title": "Portability Across DOE Office of Science HPC Facilities"
        }, 
        {
            "location": "/facilities/overview/", 
            "text": "This should be high level overview of differences at centers - we can then cover more in comparison\n\n\nThe \nAdvanced Scientific Computing Research\n\nprogram in DOE Office of Science sponsors three computing facilities - \nthe\nArgonne Leadership Computing Facility\n (ALCF), the\n\nOak Ridge Leadership Computing Facility\n (OLCF),\nand the \nNational Energy Research Scientific Computing\nCenter\n (NERSC). Below we summarize the technical\nspecifications of the current or upcoming computing systems deployed at each\nfacility.\n\n\n\n\n\n\n\n\nSystem\n\n\nFacility\n\n\nModel\n\n\nProcessor\n\n\nAccelerator\n\n\nNodes\n\n\nPerf. Per Node\n\n\nPeak Perf.\n\n\n\n\n\n\n\n\n\n\nAurora\n\n\nALCF\n\n\nIntel\n\n\nIntel Xeon Phi (3\nrd\n gen)\n\n\n(none)\n\n\n50 000\n\n\n?\n\n\n?\n\n\n\n\n\n\nCori\n\n\nNERSC\n\n\nCray XC40\n\n\nIntel Xeon Phi (2\nnd\n gen)\n\n\n(none)\n\n\n9 688\n\n\n2.6 TF\n\n\n30 PF\n\n\n\n\n\n\nSummit\n\n\nOLCF\n\n\nIBM\n\n\nIBM POWER9\n\n\nNVIDIA Tesla (\"Volta\")\n\n\n~4 600\n\n\n 40 TF\n\n\n?\n\n\n\n\n\n\nTheta\n\n\nALCF\n\n\nCray XC40\n\n\nIntel Xeon Phi (2\nnd\n gen)\n\n\n(none)\n\n\n3 624\n\n\n2.6 TF\n\n\n10 PF\n\n\n\n\n\n\nTitan\n\n\nOLCF\n\n\nCray XK7\n\n\nAMD Opteron (\"Interlagos\")\n\n\nNVIDIA Tesla (\"Kepler\")\n\n\n18 688\n\n\n1.4 TF\n\n\n27 PF", 
            "title": "Overview"
        }, 
        {
            "location": "/facilities/overview/#this-should-be-high-level-overview-of-differences-at-centers-we-can-then-cover-more-in-comparison", 
            "text": "The  Advanced Scientific Computing Research \nprogram in DOE Office of Science sponsors three computing facilities -  the\nArgonne Leadership Computing Facility  (ALCF), the Oak Ridge Leadership Computing Facility  (OLCF),\nand the  National Energy Research Scientific Computing\nCenter  (NERSC). Below we summarize the technical\nspecifications of the current or upcoming computing systems deployed at each\nfacility.     System  Facility  Model  Processor  Accelerator  Nodes  Perf. Per Node  Peak Perf.      Aurora  ALCF  Intel  Intel Xeon Phi (3 rd  gen)  (none)  50 000  ?  ?    Cori  NERSC  Cray XC40  Intel Xeon Phi (2 nd  gen)  (none)  9 688  2.6 TF  30 PF    Summit  OLCF  IBM  IBM POWER9  NVIDIA Tesla (\"Volta\")  ~4 600   40 TF  ?    Theta  ALCF  Cray XC40  Intel Xeon Phi (2 nd  gen)  (none)  3 624  2.6 TF  10 PF    Titan  OLCF  Cray XK7  AMD Opteron (\"Interlagos\")  NVIDIA Tesla (\"Kepler\")  18 688  1.4 TF  27 PF", 
            "title": "This should be high level overview of differences at centers - we can then cover more in comparison"
        }, 
        {
            "location": "/facilities/tools/", 
            "text": "Performance Analysis Tools\n\n\nEvaluating application performance portability across diverse computing\narchitectures often requires the aid of performance analysis tools. Such tools\nprovide detailed information and statistics characterizing an application's\nusage of the architecture, and can guide the developer as she optimizes\nbottlenecks to achieve higher performance.\n\n\nEach ASCR facility is equipped with a wide range of tools for measuring\napplication performance. The applications running at the three facilities\nexhibit a broad range of demands from computer architectures - some are limited\nby memory bandwidth, others by latency, and others still by the CPU itself. The\nperformance measurement tools available at the ASCR facilities can measure in\ndetail how an application uses each of these resources. They include, but are\nnot limited to, the list provided below. The description of each tool is copied\nfrom its official documentation.\n\n\n\n\nAllinea MAP\n:\n  Allinea MAP is the profiler for parallel, multithreaded or single threaded C,\n  C++, Fortran and F90 codes. It provides in depth analysis and bottleneck\n  pinpointing to the source line.\n\n\nCray Performance Measurement and Analysis\n  Tools\n:\n  The Cray Performance Measurement and Analysis Tools (or CrayPat) are a suite\n  of utilities that enable the user to capture and analyze performance data\n  generated during the execution of a program on a Cray system. The information\n  collected and analysis produced by use of these tools can help the user to\n  find answers to two fundamental programming questions: \nHow fast is my\n  program running?\n and \nHow can I make it run faster?\n\n\nIntel Advisor\n:\n  Intel Advisor is used early in the process of adding vectorization into your\n  code, or while converting parts of a serial program to a parallel\n  (multithreaded) program. It helps you explore and locate areas in which the\n  optimizations might provide significant benefit. It also helps you predict the\n  costs and benefits of adding vectorization or parallelism to those parts of\n  your program, allowing you to experiment.\n\n\nIntel VTune Amplifier\n:\n  Intel VTune Amplifier is a performance analysis tool targeted for users\n  developing serial and multithreaded applications.\n\n\nnvprof\n:\n  nvprof enables the collection of a timeline of CUDA-related activities on both\n  CPU and GPU, including kernel execution, memory transfers, memory set and CUDA\n  API calls and events or metrics for CUDA kernels\n\n\nTuning and Analysis Utilities (TAU)\n:\n  TAU Performance System is a portable profiling and tracing toolkit for\n  performance analysis of parallel programs written in Fortran, C, C++, UPC,\n  Java, Python.", 
            "title": "Tools"
        }, 
        {
            "location": "/facilities/tools/#performance-analysis-tools", 
            "text": "Evaluating application performance portability across diverse computing\narchitectures often requires the aid of performance analysis tools. Such tools\nprovide detailed information and statistics characterizing an application's\nusage of the architecture, and can guide the developer as she optimizes\nbottlenecks to achieve higher performance.  Each ASCR facility is equipped with a wide range of tools for measuring\napplication performance. The applications running at the three facilities\nexhibit a broad range of demands from computer architectures - some are limited\nby memory bandwidth, others by latency, and others still by the CPU itself. The\nperformance measurement tools available at the ASCR facilities can measure in\ndetail how an application uses each of these resources. They include, but are\nnot limited to, the list provided below. The description of each tool is copied\nfrom its official documentation.   Allinea MAP :\n  Allinea MAP is the profiler for parallel, multithreaded or single threaded C,\n  C++, Fortran and F90 codes. It provides in depth analysis and bottleneck\n  pinpointing to the source line.  Cray Performance Measurement and Analysis\n  Tools :\n  The Cray Performance Measurement and Analysis Tools (or CrayPat) are a suite\n  of utilities that enable the user to capture and analyze performance data\n  generated during the execution of a program on a Cray system. The information\n  collected and analysis produced by use of these tools can help the user to\n  find answers to two fundamental programming questions:  How fast is my\n  program running?  and  How can I make it run faster?  Intel Advisor :\n  Intel Advisor is used early in the process of adding vectorization into your\n  code, or while converting parts of a serial program to a parallel\n  (multithreaded) program. It helps you explore and locate areas in which the\n  optimizations might provide significant benefit. It also helps you predict the\n  costs and benefits of adding vectorization or parallelism to those parts of\n  your program, allowing you to experiment.  Intel VTune Amplifier :\n  Intel VTune Amplifier is a performance analysis tool targeted for users\n  developing serial and multithreaded applications.  nvprof :\n  nvprof enables the collection of a timeline of CUDA-related activities on both\n  CPU and GPU, including kernel execution, memory transfers, memory set and CUDA\n  API calls and events or metrics for CUDA kernels  Tuning and Analysis Utilities (TAU) :\n  TAU Performance System is a portable profiling and tracing toolkit for\n  performance analysis of parallel programs written in Fortran, C, C++, UPC,\n  Java, Python.", 
            "title": "Performance Analysis Tools"
        }, 
        {
            "location": "/facilities/comparison/", 
            "text": "", 
            "title": "Comparison"
        }, 
        {
            "location": "/facilities/resources/", 
            "text": "Jack / Bronson / Tim to Write", 
            "title": "Resources"
        }, 
        {
            "location": "/perfport/definition/", 
            "text": "Jack To Write", 
            "title": "Definition"
        }, 
        {
            "location": "/perfport/measurements/", 
            "text": "Measuring Performance Portability\n\n\nAs discussed in the previous section, performance portability can be an elusive topic to quantify \nand different engineers often provide different definitions or measurement techniques.\n\n\nMeasuring 'portability' itself is somewhat more well defined. One can, in principle, measure the \ntotal lines of code used in common across different architectures vs. the amount of code intended \nfor a single architecture via \nIFDEF\n pre-processing statements and the like. A code with 0% \narchitecture specfic code being completely portable and a code with a 100% architecture specific \ncode being essentially made up of multiple applications. \n\n\n'Performance', even on a single architecture, is a bit less simple to define and measure. In \npractice, scientists generally care about the quality and quantity of scientific output they \nproduce. This typically maps for them to relative performance concepts, such as how much faster \ncan a particular run or set of runs run today than yesterday or on this machine than that. The \ndrawback of trying to measure performance in this way is that the baseline is arbitrary - i.e. you \ndon't know how well your code is performing on any architecture compared to how it 'should' be \nperforming if it were well optimized.\n\n\nOne may \nin principle define absolute performance as a measure", 
            "title": "Measurements"
        }, 
        {
            "location": "/perfport/measurements/#measuring-performance-portability", 
            "text": "As discussed in the previous section, performance portability can be an elusive topic to quantify \nand different engineers often provide different definitions or measurement techniques.  Measuring 'portability' itself is somewhat more well defined. One can, in principle, measure the \ntotal lines of code used in common across different architectures vs. the amount of code intended \nfor a single architecture via  IFDEF  pre-processing statements and the like. A code with 0% \narchitecture specfic code being completely portable and a code with a 100% architecture specific \ncode being essentially made up of multiple applications.   'Performance', even on a single architecture, is a bit less simple to define and measure. In \npractice, scientists generally care about the quality and quantity of scientific output they \nproduce. This typically maps for them to relative performance concepts, such as how much faster \ncan a particular run or set of runs run today than yesterday or on this machine than that. The \ndrawback of trying to measure performance in this way is that the baseline is arbitrary - i.e. you \ndon't know how well your code is performing on any architecture compared to how it 'should' be \nperforming if it were well optimized.  One may \nin principle define absolute performance as a measure", 
            "title": "Measuring Performance Portability"
        }, 
        {
            "location": "/perfport/libraries/", 
            "text": "Libraries e.g. BLAS/FFT, MAGMA, CULA, Trillinos, PETSc\n\n\nPros\n\n\n\n\n\n\nOften encapsulate much of the computational intensity found in scientific codes\n\n\n\n\n\n\nCan allow immediate portability under some circumstances\n\n\n\n\n\n\nPerformance becomes a task for library authors/maintainers\n\n\n\n\n\n\nCons\n\n\n\n\n\n\nLimited set of portable libraries at present\n\n\n\n\n\n\nMay not capture all the important/expensive tasks in a given code  \n\n\n\n\n\n\nOften require recasting data structures to match library requirements\n\n\n\n\n\n\nOpaque interior threading models", 
            "title": "Libraries"
        }, 
        {
            "location": "/perfport/directives/", 
            "text": "Directives\n\n\nPros \n\n\n\n\n\n\nAvailable for many different languages \n\n\n\n\n\n\nGood control of execution \n\n\n\n\n\n\nAllow performance optimization\n\n\n\n\n\n\nControlled by well-defined standards bodies\n\n\n\n\n\n\nCons \n\n\n\n\n\n\nRequire compiler support \n\n\n\n\n\n\nEvolving standards", 
            "title": "Directives"
        }, 
        {
            "location": "/perfport/directives/#directives", 
            "text": "Pros     Available for many different languages     Good control of execution     Allow performance optimization    Controlled by well-defined standards bodies    Cons     Require compiler support     Evolving standards", 
            "title": "Directives"
        }, 
        {
            "location": "/perfport/frameworks/", 
            "text": "Frameworks e.g. Kokkos, RAJA\n\n\nPros \n\n\n\n\n\n\nProvide good portability through the use of platform-dependent back-ends\n\n\n\n\n\n\nPromote good programming practices\n\n\n\n\n\n\nCons\n\n\n\n\n\n\nGenerally C++ only (at present)\n\n\n\n\n\n\nDo not represent recognized standards(yet)\n\n\n\n\n\n\nEvolving quickly", 
            "title": "Frameworks"
        }, 
        {
            "location": "/perfport/frameworks/#frameworks-eg-kokkos-raja", 
            "text": "Pros     Provide good portability through the use of platform-dependent back-ends    Promote good programming practices    Cons    Generally C++ only (at present)    Do not represent recognized standards(yet)    Evolving quickly", 
            "title": "Frameworks e.g. Kokkos, RAJA"
        }, 
        {
            "location": "/perfport/dsl/", 
            "text": "", 
            "title": "DSL"
        }, 
        {
            "location": "/perfport/models/", 
            "text": "", 
            "title": "Models"
        }, 
        {
            "location": "/perfport/summary/", 
            "text": "This will be a comparison of all the approaches we tried.\n\n\n\n\n\n\n\n\nApproach\n\n\nBenefits\n\n\nChallenges\n\n\n\n\n\n\n\n\n\n\nOpenMP 4.5\n\n\nSupport for C, C++, Fortran\n\n\nreliant on quality of compiler implementation\n\n\n\n\n\n\nKokkos\n\n\n\n\n\n\n\n\n\n\nRAJA", 
            "title": "Summary"
        }, 
        {
            "location": "/case_studies/amr/overview/", 
            "text": "Thorsten / Brian to Write\n\n\nOverview of BoxLib/AMReX\n\n\nBoxLib\n is a framework for developing\nparallel, block-structured, adaptive mesh refinement (AMR) applications. It is\nwritten primarily in C++, and enables scientific application development\nthrough compute kernels written primarily in Fortran. Through the \nExascale\nComputing Project\n's\n\nBlock Structured Adaptive Mesh Refinement Co-Design\nCenter\n,\nBoxLib has since been superseded by\n\nAMReX\n. Both frameworks are publicly\navailable. The DOE COE for Performance Portability began prior to the formation\nof the Co-Design Center; consequently,the efforts described here focus on\nBoxLib, although the functionality described here is largely the same between\nthe two frameworks.\n\n\nBoxLib contains a wide variety of functionality:\n\n\n\n\nboundary condition exchange among boxes\n\n\nload balancing through regridding boxes among MPI processes\n\n\nmetadata operations such as computing volume intersections among boxes\n\n\nmemory management through pool allocators\n\n\n\n\nIn addition these, BoxLib also provides linear solvers which use geometric\nmultigrid methods to solve problems on both cell-centered and nodal data. Our\nperformance portability efforts described here focus on the cell-centered\nsolver, which is algorithmically simpler than the nodal solver.", 
            "title": "Overview"
        }, 
        {
            "location": "/case_studies/amr/overview/#overview-of-boxlibamrex", 
            "text": "BoxLib  is a framework for developing\nparallel, block-structured, adaptive mesh refinement (AMR) applications. It is\nwritten primarily in C++, and enables scientific application development\nthrough compute kernels written primarily in Fortran. Through the  Exascale\nComputing Project 's Block Structured Adaptive Mesh Refinement Co-Design\nCenter ,\nBoxLib has since been superseded by AMReX . Both frameworks are publicly\navailable. The DOE COE for Performance Portability began prior to the formation\nof the Co-Design Center; consequently,the efforts described here focus on\nBoxLib, although the functionality described here is largely the same between\nthe two frameworks.  BoxLib contains a wide variety of functionality:   boundary condition exchange among boxes  load balancing through regridding boxes among MPI processes  metadata operations such as computing volume intersections among boxes  memory management through pool allocators   In addition these, BoxLib also provides linear solvers which use geometric\nmultigrid methods to solve problems on both cell-centered and nodal data. Our\nperformance portability efforts described here focus on the cell-centered\nsolver, which is algorithmically simpler than the nodal solver.", 
            "title": "Overview of BoxLib/AMReX"
        }, 
        {
            "location": "/case_studies/amr/parallelism/", 
            "text": "Parallelization\n\n\nBoxLib implements parallelization through a hybrid MPI+OpenMP approach.\n\n\nMPI\n\n\nAt the coarsest level, BoxLib decomposes the problem domain into rectangular\nboxes, and distributes these among MPI processes. Each process follows an\n\"owner computes\" model, wherein it loops over its own boxes, executing Fortran\nkernels on each box in series. An example is shown in the figure below, where\nthe red and green boxes are assigned to the same MPI process.\n\n\n\n\nOpenMP\n\n\nBoxLib adds an additional layer of parallelism within each MPI process through\nOpenMP threading, specifically by decomposing its set of boxes into a set of\nsmaller \"tiles\", which are then distributed among OpenMP threads. Although\nthese tiles can be arbitrarily shaped, by default they are pencil-shaped, being\nlong in the stride-1 memory access dimension (the x-dimension in Fortran\nkernels), and short in the other two dimensions, in order to attain high cache\nreuse and optimal hardware memory prefetching. As with the MPI parallelism, the\nOpenMP tile box parallelism also follows an \"owner computes\" model, but at the\nfiner-grained thread level, rather than at the process level.\n\n\nThis OpenMP parallelism is illustrated in the figure below. The box\ndistribution is the same as in the figure above, except in this case each box\nis further decomposed into smaller tiles. BoxLib then builds a list of all\ntiles comprising all boxes owned by a given MPI process, and distributes the\nlist among the OpenMP threads in the process. The figure below illustrates this\nprocess by color-coding each tile, with unique threads assigned to each color,\nsuch that the same thread may operate on tiles spanning different boxes. This\napproach avoids unnecessary thread synchronization which would occur if threads\nwere distributed among tiles within each box.\n\n\n\n\nThe figures on this page are taken from the AMReX User's Guide.", 
            "title": "Parallelism"
        }, 
        {
            "location": "/case_studies/amr/parallelism/#parallelization", 
            "text": "BoxLib implements parallelization through a hybrid MPI+OpenMP approach.", 
            "title": "Parallelization"
        }, 
        {
            "location": "/case_studies/amr/parallelism/#mpi", 
            "text": "At the coarsest level, BoxLib decomposes the problem domain into rectangular\nboxes, and distributes these among MPI processes. Each process follows an\n\"owner computes\" model, wherein it loops over its own boxes, executing Fortran\nkernels on each box in series. An example is shown in the figure below, where\nthe red and green boxes are assigned to the same MPI process.", 
            "title": "MPI"
        }, 
        {
            "location": "/case_studies/amr/parallelism/#openmp", 
            "text": "BoxLib adds an additional layer of parallelism within each MPI process through\nOpenMP threading, specifically by decomposing its set of boxes into a set of\nsmaller \"tiles\", which are then distributed among OpenMP threads. Although\nthese tiles can be arbitrarily shaped, by default they are pencil-shaped, being\nlong in the stride-1 memory access dimension (the x-dimension in Fortran\nkernels), and short in the other two dimensions, in order to attain high cache\nreuse and optimal hardware memory prefetching. As with the MPI parallelism, the\nOpenMP tile box parallelism also follows an \"owner computes\" model, but at the\nfiner-grained thread level, rather than at the process level.  This OpenMP parallelism is illustrated in the figure below. The box\ndistribution is the same as in the figure above, except in this case each box\nis further decomposed into smaller tiles. BoxLib then builds a list of all\ntiles comprising all boxes owned by a given MPI process, and distributes the\nlist among the OpenMP threads in the process. The figure below illustrates this\nprocess by color-coding each tile, with unique threads assigned to each color,\nsuch that the same thread may operate on tiles spanning different boxes. This\napproach avoids unnecessary thread synchronization which would occur if threads\nwere distributed among tiles within each box.   The figures on this page are taken from the AMReX User's Guide.", 
            "title": "OpenMP"
        }, 
        {
            "location": "/case_studies/amr/code_layout/", 
            "text": "Code Layout\n\n\nThe typical form of a BoxLib application is a C++ \"driver\" code which manages\nthe boxes on the domain, and calls Fortran kernels in a loop over the boxes\nowned by each MPI process. An example of this layout is shown below:\n\n\n// Advance the solution one grid at a time\n\n\nfor\n \n(\n \nMFIter\n \nmfi\n(\nold_phi\n);\n \nmfi\n.\nisValid\n();\n \n++\nmfi\n \n)\n\n\n{\n\n  \nconst\n \nBox\n \nbx\n \n=\n \nmfi\n.\nvalidbox\n();\n\n\n  \nupdate_phi\n(\nold_phi\n[\nmfi\n].\ndataPtr\n(),\n\n             \nnew_phi\n[\nmfi\n].\ndataPtr\n(),\n\n             \nng_p\n,\n\n             \nflux\n[\n0\n][\nmfi\n].\ndataPtr\n(),\n\n             \nflux\n[\n1\n][\nmfi\n].\ndataPtr\n(),\n\n             \nflux\n[\n2\n][\nmfi\n].\ndataPtr\n(),\n\n             \nng_f\n,\n \nbx\n.\nloVect\n(),\n \nbx\n.\nhiVect\n(),\n \ndx\n[\n0\n],\n \ndt\n);\n\n  \n}\n\n\n}\n\n\n\n\n\nHere the \nMFIter\n object is an iterator over boxes owned by an MPI process. The\n\nBox\n object contains the geometric metadata describing a particular box, e.g.,\nthe indices of the lower and upper corners. The variables \nold_phi\n, \nnew_phi\n,\nand \nflux\n contain pointers to the arrays which contain the floating point data\non the grid. The \nupdate_phi\n function is a Fortran function which uses the\ndata from the \nBox\n object to construct 3-D loops over the appropriate section\nof the three floating-point arrays. The function may look like the following:\n\n\nsubroutine \nupdate_phi\n(\nphiold\n,\n \nphinew\n,\n \nng_p\n,\n \nfluxx\n,\n \nfluxy\n,\n \nfluxz\n,\n \nng_f\n,\n \nlo\n,\n \nhi\n,\n \ndx\n,\n \ndt\n)\n \nbind\n(\nC\n,\n \nname\n=\nupdate_phi\n)\n\n\n  \ninteger\n          \n::\n \nlo\n(\n3\n),\n \nhi\n(\n3\n),\n \nng_p\n,\n \nng_f\n\n  \ndouble precision\n \n::\n \nphiold\n(\nlo\n(\n1\n)\n-\nng_p\n:\nhi\n(\n1\n)\n+\nng_p\n,\nlo\n(\n2\n)\n-\nng_p\n:\nhi\n(\n2\n)\n+\nng_p\n,\nlo\n(\n3\n)\n-\nng_p\n:\nhi\n(\n3\n)\n+\nng_p\n)\n\n  \ndouble precision\n \n::\n \nphinew\n(\nlo\n(\n1\n)\n-\nng_p\n:\nhi\n(\n1\n)\n+\nng_p\n,\nlo\n(\n2\n)\n-\nng_p\n:\nhi\n(\n2\n)\n+\nng_p\n,\nlo\n(\n3\n)\n-\nng_p\n:\nhi\n(\n3\n)\n+\nng_p\n)\n\n  \ndouble precision\n \n::\n  \nfluxx\n(\nlo\n(\n1\n)\n-\nng_f\n:\nhi\n(\n1\n)\n+\nng_f\n+\n1\n,\nlo\n(\n2\n)\n-\nng_f\n:\nhi\n(\n2\n)\n+\nng_f\n,\nlo\n(\n3\n)\n-\nng_f\n:\nhi\n(\n3\n)\n+\nng_f\n)\n\n  \ndouble precision\n \n::\n  \nfluxy\n(\nlo\n(\n1\n)\n-\nng_f\n:\nhi\n(\n1\n)\n+\nng_f\n,\nlo\n(\n2\n)\n-\nng_f\n:\nhi\n(\n2\n)\n+\nng_f\n+\n1\n,\nlo\n(\n3\n)\n-\nng_f\n:\nhi\n(\n3\n)\n+\nng_f\n)\n\n  \ndouble precision\n \n::\n  \nfluxz\n(\nlo\n(\n1\n)\n-\nng_f\n:\nhi\n(\n1\n)\n+\nng_f\n,\nlo\n(\n2\n)\n-\nng_f\n:\nhi\n(\n2\n)\n+\nng_f\n,\nlo\n(\n3\n)\n-\nng_f\n:\nhi\n(\n3\n)\n+\nng_f\n+\n1\n)\n\n  \ndouble precision\n \n::\n \ndx\n,\n \ndt\n\n\n  \ninteger \ni\n,\nj\n,\nk\n\n\n  \ndo \nk\n=\nlo\n(\n3\n),\nhi\n(\n3\n)\n\n     \ndo \nj\n=\nlo\n(\n2\n),\nhi\n(\n2\n)\n\n        \ndo \ni\n=\nlo\n(\n1\n),\nhi\n(\n1\n)\n\n\n           \nphinew\n(\ni\n,\nj\n,\nk\n)\n \n=\n \nphiold\n(\ni\n,\nj\n,\nk\n)\n \n+\n \ndt\n \n*\n \n\n                \n(\n \nfluxx\n(\ni\n+\n1\n,\nj\n,\nk\n)\n-\nfluxx\n(\ni\n,\nj\n,\nk\n)\n \n\n                \n+\nfluxy\n(\ni\n,\nj\n+\n1\n,\nk\n)\n-\nfluxy\n(\ni\n,\nj\n,\nk\n)\n \n\n                \n+\nfluxz\n(\ni\n,\nj\n,\nk\n+\n1\n)\n-\nfluxz\n(\ni\n,\nj\n,\nk\n)\n \n)\n \n/\n \ndx\n\n\n        \nend do\n\n\n     end do\n\n\n  end do\n\n\n\n\n\nThe Fortran function constructs the appropriate \"view\" into each box using the\ndata from the \nBox\n object from the C++ function, as well as from the number of\nghost zones (\nng_p\n for \nold_phi\n and \nnew_phi\n, and \nng_f\n for \nflux\n).\n\n\nThe above example demonstrates pure MPI parallelism; the analogous C++ code\nwhich uses OpenMP tiling as described above would look like the following:\n\n\n// Advance the solution one grid at a time\n\n\n#ifdef _OPENMP\n\n\n#pragma omp parallel\n\n\n#endif\n\n\nfor\n \n(\n \nMFIter\n \nmfi\n(\nold_phi\n,\ntrue\n);\n \nmfi\n.\nisValid\n();\n \n++\nmfi\n \n)\n\n\n{\n\n  \nconst\n \nBox\n \ntbx\n \n=\n \nmfi\n.\ntilebox\n();\n\n\n  \nupdate_phi\n(\nold_phi\n[\nmfi\n].\ndataPtr\n(),\n\n             \nnew_phi\n[\nmfi\n].\ndataPtr\n(),\n\n             \nng_p\n,\n\n             \nflux\n[\n0\n][\nmfi\n].\ndataPtr\n(),\n\n             \nflux\n[\n1\n][\nmfi\n].\ndataPtr\n(),\n\n             \nflux\n[\n2\n][\nmfi\n].\ndataPtr\n(),\n\n             \nng_f\n,\n \ntbx\n.\nloVect\n(),\n \ntbx\n.\nhiVect\n(),\n \ndx\n[\n0\n],\n \ndt\n);\n\n  \n}\n\n\n}\n\n\n\n\n\nThe OpenMP parallelism is coarse-grained; rather than constructing a large\n\nBox\n from \nmfi.validbox()\n, it constructs a smaller \nBox\n from\n\nmfi.tilebox()\n. The metadata format remains unchanged, allowing the Fortran\nfunction to remain unchanged as well.", 
            "title": "Code Layout"
        }, 
        {
            "location": "/case_studies/amr/code_layout/#code-layout", 
            "text": "The typical form of a BoxLib application is a C++ \"driver\" code which manages\nthe boxes on the domain, and calls Fortran kernels in a loop over the boxes\nowned by each MPI process. An example of this layout is shown below:  // Advance the solution one grid at a time  for   (   MFIter   mfi ( old_phi );   mfi . isValid ();   ++ mfi   )  { \n   const   Box   bx   =   mfi . validbox (); \n\n   update_phi ( old_phi [ mfi ]. dataPtr (), \n              new_phi [ mfi ]. dataPtr (), \n              ng_p , \n              flux [ 0 ][ mfi ]. dataPtr (), \n              flux [ 1 ][ mfi ]. dataPtr (), \n              flux [ 2 ][ mfi ]. dataPtr (), \n              ng_f ,   bx . loVect (),   bx . hiVect (),   dx [ 0 ],   dt ); \n   }  }   Here the  MFIter  object is an iterator over boxes owned by an MPI process. The Box  object contains the geometric metadata describing a particular box, e.g.,\nthe indices of the lower and upper corners. The variables  old_phi ,  new_phi ,\nand  flux  contain pointers to the arrays which contain the floating point data\non the grid. The  update_phi  function is a Fortran function which uses the\ndata from the  Box  object to construct 3-D loops over the appropriate section\nof the three floating-point arrays. The function may look like the following:  subroutine  update_phi ( phiold ,   phinew ,   ng_p ,   fluxx ,   fluxy ,   fluxz ,   ng_f ,   lo ,   hi ,   dx ,   dt )   bind ( C ,   name = update_phi ) \n\n   integer            ::   lo ( 3 ),   hi ( 3 ),   ng_p ,   ng_f \n   double precision   ::   phiold ( lo ( 1 ) - ng_p : hi ( 1 ) + ng_p , lo ( 2 ) - ng_p : hi ( 2 ) + ng_p , lo ( 3 ) - ng_p : hi ( 3 ) + ng_p ) \n   double precision   ::   phinew ( lo ( 1 ) - ng_p : hi ( 1 ) + ng_p , lo ( 2 ) - ng_p : hi ( 2 ) + ng_p , lo ( 3 ) - ng_p : hi ( 3 ) + ng_p ) \n   double precision   ::    fluxx ( lo ( 1 ) - ng_f : hi ( 1 ) + ng_f + 1 , lo ( 2 ) - ng_f : hi ( 2 ) + ng_f , lo ( 3 ) - ng_f : hi ( 3 ) + ng_f ) \n   double precision   ::    fluxy ( lo ( 1 ) - ng_f : hi ( 1 ) + ng_f , lo ( 2 ) - ng_f : hi ( 2 ) + ng_f + 1 , lo ( 3 ) - ng_f : hi ( 3 ) + ng_f ) \n   double precision   ::    fluxz ( lo ( 1 ) - ng_f : hi ( 1 ) + ng_f , lo ( 2 ) - ng_f : hi ( 2 ) + ng_f , lo ( 3 ) - ng_f : hi ( 3 ) + ng_f + 1 ) \n   double precision   ::   dx ,   dt \n\n   integer  i , j , k \n\n   do  k = lo ( 3 ), hi ( 3 ) \n      do  j = lo ( 2 ), hi ( 2 ) \n         do  i = lo ( 1 ), hi ( 1 ) \n\n            phinew ( i , j , k )   =   phiold ( i , j , k )   +   dt   *   \n                 (   fluxx ( i + 1 , j , k ) - fluxx ( i , j , k )   \n                 + fluxy ( i , j + 1 , k ) - fluxy ( i , j , k )   \n                 + fluxz ( i , j , k + 1 ) - fluxz ( i , j , k )   )   /   dx \n\n         end do       end do    end do   The Fortran function constructs the appropriate \"view\" into each box using the\ndata from the  Box  object from the C++ function, as well as from the number of\nghost zones ( ng_p  for  old_phi  and  new_phi , and  ng_f  for  flux ).  The above example demonstrates pure MPI parallelism; the analogous C++ code\nwhich uses OpenMP tiling as described above would look like the following:  // Advance the solution one grid at a time  #ifdef _OPENMP  #pragma omp parallel  #endif  for   (   MFIter   mfi ( old_phi , true );   mfi . isValid ();   ++ mfi   )  { \n   const   Box   tbx   =   mfi . tilebox (); \n\n   update_phi ( old_phi [ mfi ]. dataPtr (), \n              new_phi [ mfi ]. dataPtr (), \n              ng_p , \n              flux [ 0 ][ mfi ]. dataPtr (), \n              flux [ 1 ][ mfi ]. dataPtr (), \n              flux [ 2 ][ mfi ]. dataPtr (), \n              ng_f ,   tbx . loVect (),   tbx . hiVect (),   dx [ 0 ],   dt ); \n   }  }   The OpenMP parallelism is coarse-grained; rather than constructing a large Box  from  mfi.validbox() , it constructs a smaller  Box  from mfi.tilebox() . The metadata format remains unchanged, allowing the Fortran\nfunction to remain unchanged as well.", 
            "title": "Code Layout"
        }, 
        {
            "location": "/case_studies/amr/multigrid/", 
            "text": "Geometric Multigrid\n\n\nMany problems encountered in BoxLib applications require solutions to linear\nsystem, e.g., elliptic partial differential equations such as the Poisson\nequation for self-gravity, and the diffusion equation. BoxLib therefore\nincludes geometric multigrid solvers for solving problems which use both\ncell-centered and nodal data. For this project, we have focused on the\ncell-centered solver due to its relative simplicity compared to the nodal\nsolver.\n\n\nGeometric multigrid is an iterative method for solving linear problems which\ncontains roughly 4 steps:\n\n\n\n\nrelaxation\n\n\nrestriction\n\n\nprolongation\n\n\ncoarse-grid linear solve (either approximate or exact)\n\n\n\n\nAlthough here we will not discuss the details of the geometric multigrid\nmethod, we summarize each of these steps below as they pertain to computational\nalgorithms. Although these steps are algorithmically unique, we note that all\nof them feature low arithmetic intensity and are thus sensitive to cache and\nmemory bandwidth.\n\n\nRelaxation\n\n\nA relaxation consists of one or more iterations of an approximate solution to\nthe system of linear equations. In geometric multigrid, common algorithms used\nhere include Jacobi and Gauss-Seidel. By default, the BoxLib solver uses a\nvariation on Gauss-Seidel called Gauss-Seidel red-black (\"GSRB\"). GSRB deviates\nfrom the original Gauss-Seidel method by exploiting a symmetry in the data\ndependence among matrix elements, such that an update sweep of all matrix\nelements follows a stride-2 pattern rather than stride-1. (This property\nmanifests in the innermost loop of the kernel shown below).\n\n\ndo \nk\n \n=\n \nlo\n(\n3\n),\n \nhi\n(\n3\n)\n\n  \ndo \nj\n \n=\n \nlo\n(\n2\n),\n \nhi\n(\n2\n)\n\n     \nioff\n \n=\n \nMOD\n(\nlo\n(\n1\n)\n \n+\n \nj\n \n+\n \nk\n \n+\n \nredblack\n,\n2\n)\n\n     \ndo \ni\n \n=\n \nlo\n(\n1\n)\n \n+\n \nioff\n,\nhi\n(\n1\n),\n2\n\n        \ngamma\n \n=\n \nalpha\n*\na\n(\ni\n,\nj\n,\nk\n)\n \n\n              \n+\n   \ndhx\n*\n(\nbX\n(\ni\n,\nj\n,\nk\n)\n+\nbX\n(\ni\n+\n1\n,\nj\n,\nk\n))\n \n\n              \n+\n   \ndhy\n*\n(\nbY\n(\ni\n,\nj\n,\nk\n)\n+\nbY\n(\ni\n,\nj\n+\n1\n,\nk\n))\n \n\n              \n+\n   \ndhz\n*\n(\nbZ\n(\ni\n,\nj\n,\nk\n)\n+\nbZ\n(\ni\n,\nj\n,\nk\n+\n1\n))\n\n\n        \ng_m_d\n \n=\n \ngamma\n \n\n              \n-\n \n(\ndhx\n*\n(\nbX\n(\ni\n,\nj\n,\nk\n)\n*\ncf0\n \n+\n \nbX\n(\ni\n+\n1\n,\nj\n,\nk\n)\n*\ncf3\n)\n \n\n              \n+\n  \ndhy\n*\n(\nbY\n(\ni\n,\nj\n,\nk\n)\n*\ncf1\n \n+\n \nbY\n(\ni\n,\nj\n+\n1\n,\nk\n)\n*\ncf4\n)\n \n\n              \n+\n  \ndhz\n*\n(\nbZ\n(\ni\n,\nj\n,\nk\n)\n*\ncf2\n \n+\n \nbZ\n(\ni\n,\nj\n,\nk\n+\n1\n)\n*\ncf5\n))\n \n\n\n        \nrho\n \n=\n \ndhx\n*\n(\n \nbX\n(\ni\n  \n,\nj\n,\nk\n)\n*\nphi\n(\ni\n-\n1\n,\nj\n,\nk\n)\n \n\n            \n+\n       \nbX\n(\ni\n+\n1\n,\nj\n,\nk\n)\n*\nphi\n(\ni\n+\n1\n,\nj\n,\nk\n)\n \n)\n \n\n            \n+\n \ndhy\n*\n(\n \nbY\n(\ni\n,\nj\n  \n,\nk\n)\n*\nphi\n(\ni\n,\nj\n-\n1\n,\nk\n)\n \n\n            \n+\n       \nbY\n(\ni\n,\nj\n+\n1\n,\nk\n)\n*\nphi\n(\ni\n,\nj\n+\n1\n,\nk\n)\n \n)\n \n\n            \n+\n \ndhz\n*\n(\n \nbZ\n(\ni\n,\nj\n,\nk\n  \n)\n*\nphi\n(\ni\n,\nj\n,\nk\n-\n1\n)\n \n\n            \n+\n       \nbZ\n(\ni\n,\nj\n,\nk\n+\n1\n)\n*\nphi\n(\ni\n,\nj\n,\nk\n+\n1\n)\n \n)\n \n\n\n        \nres\n \n=\n  \nrhs\n(\ni\n,\nj\n,\nk\n)\n \n-\n \n(\ngamma\n*\nphi\n(\ni\n,\nj\n,\nk\n)\n \n-\n \nrho\n)\n\n        \nphi\n(\ni\n,\nj\n,\nk\n)\n \n=\n \nphi\n(\ni\n,\nj\n,\nk\n)\n \n+\n \nomega\n/\ng_m_d\n \n*\n \nres\n\n     \nend do\n\n\n  end do\n\n\nend do\n\n\n\n\n\nThe algorithm above uses a 7-point cell-centered discretization of the 3-D\nvariable-coefficient Helmholtz operator. The diffusion operator is one type of\nHelmholtz operator; the Laplace operator, which appears in the Poisson equation\nfor self-gravity, is a simplified version, with constant coefficients.\n\n\nThe GSRB method for a 7-point discretization of the Helmholtz operator exhibits\na low arithmetic intensity, requiring several non-contiguous loads from memory\nto evaluate the operator.\n\n\nThe relaxation step and the coarse grid solve (discussed belowed) often feature\nsimilar computational and data access patterns, because both are effectively\ndoing the same thing - solving a linear system. The primary difference between\nthem is that the relaxation method applies the iterative kernel only a handful\nof times, whereas the coarse grid solve often iterates all the way to\nconvergence.\n\n\nRestriction\n\n\nDuring a restriction, the value of a field on a fine grid is approximated on a\ncoarser grid. This is typically done by averaging values of the field on fine\ngrid points onto the corresponding grid points on the coarse grid. In BoxLib,\nthe algorithm is the following:\n\n\ndo \nk\n \n=\n \nlo\n(\n3\n),\n \nhi\n(\n3\n)\n\n  \nk2\n \n=\n \n2\n*\nk\n\n  \nk2p1\n \n=\n \nk2\n \n+\n \n1\n\n  \ndo \nj\n \n=\n \nlo\n(\n2\n),\n \nhi\n(\n2\n)\n\n    \nj2\n \n=\n \n2\n*\nj\n\n    \nj2p1\n \n=\n \nj2\n \n+\n \n1\n\n    \ndo \ni\n \n=\n \nlo\n(\n1\n),\n \nhi\n(\n1\n)\n\n      \ni2\n \n=\n \n2\n*\ni\n\n      \ni2p1\n \n=\n \ni2\n \n+\n \n1\n\n      \nc\n(\ni\n,\nj\n,\nk\n)\n \n=\n  \n(\n\n\n$\n                 \n+\n \nf\n(\ni2p1\n,\nj2p1\n,\nk2\n  \n)\n \n+\n \nf\n(\ni2\n,\nj2p1\n,\nk2\n  \n)\n\n\n$\n                 \n+\n \nf\n(\ni2p1\n,\nj2\n  \n,\nk2\n  \n)\n \n+\n \nf\n(\ni2\n,\nj2\n  \n,\nk2\n  \n)\n\n\n$\n                 \n+\n \nf\n(\ni2p1\n,\nj2p1\n,\nk2p1\n)\n \n+\n \nf\n(\ni2\n,\nj2p1\n,\nk2p1\n)\n\n\n$\n                 \n+\n \nf\n(\ni2p1\n,\nj2\n  \n,\nk2p1\n)\n \n+\n \nf\n(\ni2\n,\nj2\n  \n,\nk2p1\n)\n\n\n$\n                 \n)\n*\neighth\n\n    \nend do\n\n\n  end do\n\n\nend do\n\n\n\n\n\nwhere \nf\n is the field on the fine grid and \nc\n is the field on the coarse\ngrid. (This multigrid solver always coarsens grids by factors of two in each\ndimension.) For each evaluation of a coarse grid point, the algorithm must load\n8 values from the fine grid. However, there is significant memory locality in\nthis algorithm, as many of the fine grid points for coarse grid point\n\nc(i,j,k)\n also contribute to the point \nc(i+1,j,k)\n.\n\n\nProlongation\n\n\nProlongation (also called interpolation) is the opposite of restriction: one\napproximates the value of a field on a coarse grid on a finer grid. The\nprolongation kernel in the BoxLib solver is as follows:\n\ndo \nk\n \n=\n \nlo\n(\n3\n),\n \nhi\n(\n3\n)\n\n  \nk2\n \n=\n \n2\n*\nk\n\n  \nk2p1\n \n=\n \nk2\n \n+\n \n1\n\n  \ndo \nj\n \n=\n \nlo\n(\n2\n),\n \nhi\n(\n2\n)\n\n    \nj2\n \n=\n \n2\n*\nj\n\n    \nj2p1\n \n=\n \nj2\n \n+\n \n1\n\n    \ndo \ni\n \n=\n \nlo\n(\n1\n),\n \nhi\n(\n1\n)\n\n      \ni2\n \n=\n \n2\n*\ni\n\n      \ni2p1\n \n=\n \ni2\n \n+\n \n1\n\n\n      \nf\n(\ni2p1\n,\nj2p1\n,\nk2\n  \n)\n \n=\n \nc\n(\ni\n,\nj\n,\nk\n)\n \n+\n \nf\n(\ni2p1\n,\nj2p1\n,\nk2\n  \n)\n\n      \nf\n(\ni2\n  \n,\nj2p1\n,\nk2\n  \n)\n \n=\n \nc\n(\ni\n,\nj\n,\nk\n)\n \n+\n \nf\n(\ni2\n  \n,\nj2p1\n,\nk2\n  \n)\n\n      \nf\n(\ni2p1\n,\nj2\n  \n,\nk2\n  \n)\n \n=\n \nc\n(\ni\n,\nj\n,\nk\n)\n \n+\n \nf\n(\ni2p1\n,\nj2\n  \n,\nk2\n  \n)\n\n      \nf\n(\ni2\n  \n,\nj2\n  \n,\nk2\n  \n)\n \n=\n \nc\n(\ni\n,\nj\n,\nk\n)\n \n+\n \nf\n(\ni2\n  \n,\nj2\n  \n,\nk2\n  \n)\n\n      \nf\n(\ni2p1\n,\nj2p1\n,\nk2p1\n)\n \n=\n \nc\n(\ni\n,\nj\n,\nk\n)\n \n+\n \nf\n(\ni2p1\n,\nj2p1\n,\nk2p1\n)\n\n      \nf\n(\ni2\n  \n,\nj2p1\n,\nk2p1\n)\n \n=\n \nc\n(\ni\n,\nj\n,\nk\n)\n \n+\n \nf\n(\ni2\n  \n,\nj2p1\n,\nk2p1\n)\n\n      \nf\n(\ni2p1\n,\nj2\n  \n,\nk2p1\n)\n \n=\n \nc\n(\ni\n,\nj\n,\nk\n)\n \n+\n \nf\n(\ni2p1\n,\nj2\n  \n,\nk2p1\n)\n\n      \nf\n(\ni2\n  \n,\nj2\n  \n,\nk2p1\n)\n \n=\n \nc\n(\ni\n,\nj\n,\nk\n)\n \n+\n \nf\n(\ni2\n  \n,\nj2\n  \n,\nk2p1\n)\n\n\n    \nend do\n\n\n  end do\n\n\nend do\n\n\n\n\nIn 3-D, the same value on the coarse grid contributes equally to eight\nneighboring points in the fine grid. (The symmetry arises from the constraint\nin the solver that the cells must be cubic.)\n\n\nExact linear solve\n\n\nThe multigrid solver in BoxLib recursively coarsens grids until the grid\nreaches a sufficiently small size, often \n\\(2^3\\)\n if the problem domain is cubic.\nOn the coarsest grid, the solver then solves the linear system exactly, before\npropagating the solution back up to finer grids. The solution algorithm chosen\nfor this step is rarely influential on the overall performance of the multigrid\nalgorithm, because the problem size at the coarsest grid is so small. In\nBoxLib, the default coarse grid solver algorithm is BiCGSTAB, a variation on\nthe conjugate-gradient iterative method.", 
            "title": "Geometric Multigrid"
        }, 
        {
            "location": "/case_studies/amr/multigrid/#geometric-multigrid", 
            "text": "Many problems encountered in BoxLib applications require solutions to linear\nsystem, e.g., elliptic partial differential equations such as the Poisson\nequation for self-gravity, and the diffusion equation. BoxLib therefore\nincludes geometric multigrid solvers for solving problems which use both\ncell-centered and nodal data. For this project, we have focused on the\ncell-centered solver due to its relative simplicity compared to the nodal\nsolver.  Geometric multigrid is an iterative method for solving linear problems which\ncontains roughly 4 steps:   relaxation  restriction  prolongation  coarse-grid linear solve (either approximate or exact)   Although here we will not discuss the details of the geometric multigrid\nmethod, we summarize each of these steps below as they pertain to computational\nalgorithms. Although these steps are algorithmically unique, we note that all\nof them feature low arithmetic intensity and are thus sensitive to cache and\nmemory bandwidth.", 
            "title": "Geometric Multigrid"
        }, 
        {
            "location": "/case_studies/amr/multigrid/#relaxation", 
            "text": "A relaxation consists of one or more iterations of an approximate solution to\nthe system of linear equations. In geometric multigrid, common algorithms used\nhere include Jacobi and Gauss-Seidel. By default, the BoxLib solver uses a\nvariation on Gauss-Seidel called Gauss-Seidel red-black (\"GSRB\"). GSRB deviates\nfrom the original Gauss-Seidel method by exploiting a symmetry in the data\ndependence among matrix elements, such that an update sweep of all matrix\nelements follows a stride-2 pattern rather than stride-1. (This property\nmanifests in the innermost loop of the kernel shown below).  do  k   =   lo ( 3 ),   hi ( 3 ) \n   do  j   =   lo ( 2 ),   hi ( 2 ) \n      ioff   =   MOD ( lo ( 1 )   +   j   +   k   +   redblack , 2 ) \n      do  i   =   lo ( 1 )   +   ioff , hi ( 1 ), 2 \n         gamma   =   alpha * a ( i , j , k )   \n               +     dhx * ( bX ( i , j , k ) + bX ( i + 1 , j , k ))   \n               +     dhy * ( bY ( i , j , k ) + bY ( i , j + 1 , k ))   \n               +     dhz * ( bZ ( i , j , k ) + bZ ( i , j , k + 1 )) \n\n         g_m_d   =   gamma   \n               -   ( dhx * ( bX ( i , j , k ) * cf0   +   bX ( i + 1 , j , k ) * cf3 )   \n               +    dhy * ( bY ( i , j , k ) * cf1   +   bY ( i , j + 1 , k ) * cf4 )   \n               +    dhz * ( bZ ( i , j , k ) * cf2   +   bZ ( i , j , k + 1 ) * cf5 ))   \n\n         rho   =   dhx * (   bX ( i    , j , k ) * phi ( i - 1 , j , k )   \n             +         bX ( i + 1 , j , k ) * phi ( i + 1 , j , k )   )   \n             +   dhy * (   bY ( i , j    , k ) * phi ( i , j - 1 , k )   \n             +         bY ( i , j + 1 , k ) * phi ( i , j + 1 , k )   )   \n             +   dhz * (   bZ ( i , j , k    ) * phi ( i , j , k - 1 )   \n             +         bZ ( i , j , k + 1 ) * phi ( i , j , k + 1 )   )   \n\n         res   =    rhs ( i , j , k )   -   ( gamma * phi ( i , j , k )   -   rho ) \n         phi ( i , j , k )   =   phi ( i , j , k )   +   omega / g_m_d   *   res \n      end do    end do  end do   The algorithm above uses a 7-point cell-centered discretization of the 3-D\nvariable-coefficient Helmholtz operator. The diffusion operator is one type of\nHelmholtz operator; the Laplace operator, which appears in the Poisson equation\nfor self-gravity, is a simplified version, with constant coefficients.  The GSRB method for a 7-point discretization of the Helmholtz operator exhibits\na low arithmetic intensity, requiring several non-contiguous loads from memory\nto evaluate the operator.  The relaxation step and the coarse grid solve (discussed belowed) often feature\nsimilar computational and data access patterns, because both are effectively\ndoing the same thing - solving a linear system. The primary difference between\nthem is that the relaxation method applies the iterative kernel only a handful\nof times, whereas the coarse grid solve often iterates all the way to\nconvergence.", 
            "title": "Relaxation"
        }, 
        {
            "location": "/case_studies/amr/multigrid/#restriction", 
            "text": "During a restriction, the value of a field on a fine grid is approximated on a\ncoarser grid. This is typically done by averaging values of the field on fine\ngrid points onto the corresponding grid points on the coarse grid. In BoxLib,\nthe algorithm is the following:  do  k   =   lo ( 3 ),   hi ( 3 ) \n   k2   =   2 * k \n   k2p1   =   k2   +   1 \n   do  j   =   lo ( 2 ),   hi ( 2 ) \n     j2   =   2 * j \n     j2p1   =   j2   +   1 \n     do  i   =   lo ( 1 ),   hi ( 1 ) \n       i2   =   2 * i \n       i2p1   =   i2   +   1 \n       c ( i , j , k )   =    (  $                   +   f ( i2p1 , j2p1 , k2    )   +   f ( i2 , j2p1 , k2    )  $                   +   f ( i2p1 , j2    , k2    )   +   f ( i2 , j2    , k2    )  $                   +   f ( i2p1 , j2p1 , k2p1 )   +   f ( i2 , j2p1 , k2p1 )  $                   +   f ( i2p1 , j2    , k2p1 )   +   f ( i2 , j2    , k2p1 )  $                   ) * eighth \n     end do    end do  end do   where  f  is the field on the fine grid and  c  is the field on the coarse\ngrid. (This multigrid solver always coarsens grids by factors of two in each\ndimension.) For each evaluation of a coarse grid point, the algorithm must load\n8 values from the fine grid. However, there is significant memory locality in\nthis algorithm, as many of the fine grid points for coarse grid point c(i,j,k)  also contribute to the point  c(i+1,j,k) .", 
            "title": "Restriction"
        }, 
        {
            "location": "/case_studies/amr/multigrid/#prolongation", 
            "text": "Prolongation (also called interpolation) is the opposite of restriction: one\napproximates the value of a field on a coarse grid on a finer grid. The\nprolongation kernel in the BoxLib solver is as follows: do  k   =   lo ( 3 ),   hi ( 3 ) \n   k2   =   2 * k \n   k2p1   =   k2   +   1 \n   do  j   =   lo ( 2 ),   hi ( 2 ) \n     j2   =   2 * j \n     j2p1   =   j2   +   1 \n     do  i   =   lo ( 1 ),   hi ( 1 ) \n       i2   =   2 * i \n       i2p1   =   i2   +   1 \n\n       f ( i2p1 , j2p1 , k2    )   =   c ( i , j , k )   +   f ( i2p1 , j2p1 , k2    ) \n       f ( i2    , j2p1 , k2    )   =   c ( i , j , k )   +   f ( i2    , j2p1 , k2    ) \n       f ( i2p1 , j2    , k2    )   =   c ( i , j , k )   +   f ( i2p1 , j2    , k2    ) \n       f ( i2    , j2    , k2    )   =   c ( i , j , k )   +   f ( i2    , j2    , k2    ) \n       f ( i2p1 , j2p1 , k2p1 )   =   c ( i , j , k )   +   f ( i2p1 , j2p1 , k2p1 ) \n       f ( i2    , j2p1 , k2p1 )   =   c ( i , j , k )   +   f ( i2    , j2p1 , k2p1 ) \n       f ( i2p1 , j2    , k2p1 )   =   c ( i , j , k )   +   f ( i2p1 , j2    , k2p1 ) \n       f ( i2    , j2    , k2p1 )   =   c ( i , j , k )   +   f ( i2    , j2    , k2p1 ) \n\n     end do    end do  end do   In 3-D, the same value on the coarse grid contributes equally to eight\nneighboring points in the fine grid. (The symmetry arises from the constraint\nin the solver that the cells must be cubic.)", 
            "title": "Prolongation"
        }, 
        {
            "location": "/case_studies/amr/multigrid/#exact-linear-solve", 
            "text": "The multigrid solver in BoxLib recursively coarsens grids until the grid\nreaches a sufficiently small size, often  \\(2^3\\)  if the problem domain is cubic.\nOn the coarsest grid, the solver then solves the linear system exactly, before\npropagating the solution back up to finer grids. The solution algorithm chosen\nfor this step is rarely influential on the overall performance of the multigrid\nalgorithm, because the problem size at the coarsest grid is so small. In\nBoxLib, the default coarse grid solver algorithm is BiCGSTAB, a variation on\nthe conjugate-gradient iterative method.", 
            "title": "Exact linear solve"
        }, 
        {
            "location": "/case_studies/gw/", 
            "text": "", 
            "title": "GW Kernels"
        }, 
        {
            "location": "/case_studies/qcd/", 
            "text": "Balint/Thorsten write this", 
            "title": "QCD"
        }, 
        {
            "location": "/case_studies/nek/", 
            "text": "", 
            "title": "NekBone"
        }, 
        {
            "location": "/case_studies/md/", 
            "text": "", 
            "title": "MD"
        }, 
        {
            "location": "/demo/demo/", 
            "text": "Welcome to NERSC\n\n\nWelcome to the National Energy Research Scientific Computing Center, a high performance scientific computing center.\nThis document will guide you through the basics of using NERSC\u2019s supercomputers, storage systems, and services.\n\n\nWhat is NERSC?\n\n\nNERSC provides High Performance Computing and Storage facilities and support for research sponsored by, and of interest to, the U.S. Department of Energy Office of Science. NERSC has the unique programmatic role of supporting all six Office of Science program offices: Advanced Scientific Computing Research, Basic Energy Sciences, Biological and Environmental Research, Fusion Energy Sciences, High Energy Physics, and Nuclear Physics. Scientists who have been awarded research funding by any of the offices are eligible to apply for an allocation of NERSC time. Additional awards may be given to non-DOE funded project teams whose research is aligned with the Office of Science's mission. Allocations of time and storage are made by DOE.\n\n\nNERSC is a national center, organizationally part of Lawrence Berkeley National Laboratory in Berkeley, CA. NERSC staff and facilities are primarily located at Berkeley Lab's Shyh Wang Hall on the Berkeley Lab campus.\n\n\nExternal links\n\n\n\n\nOLCF\n\n\nALCF\n\n\nNERSC\n\n\n\n\nInternal links\n\n\n\n\nPortability definition\n\n\n\n\nTables:\n\n\n\n\n\n\n\n\nSystem Type\n\n\nCray XC40\n\n\n\n\n\n\n\n\n\n\nTheoretical Peak Performance (System)\n\n\n31.4 PFlops\n\n\n\n\n\n\nTheoretical Peak Performance (Haswell nodes)\n\n\n2.3 PFlops\n\n\n\n\n\n\nTheoretical Peak Performance (Xeon Phi nodes)\n\n\n29.1 PFlops\n\n\n\n\n\n\nCompute Nodes (Haswell)\n\n\n2,388\n\n\n\n\n\n\n\n\nInclude scripts/ source code\n\n\nThis site supports an include extension to Markdown.\n\n\nOne way to run a pure MPI job on Cori is\n\n\n#!/bin/bash -l\n\n\n#SBATCH -p debug\n\n\n#SBATCH -N 64\n\n\n#SBATCH -t 00:20:00\n\n\n#SBATCH -J my_job\n\n\n#SBATCH -L SCRATCH\n\n\n#SBATCH -C haswell\n\n\n\n# an extra -c 2 flag is optional for fully packed pure MPI\n\nsrun -n \n2048\n ./mycode.exe\n\n\n\n\n\n\nWarning\n\n\nThe \n-c\n and \n--cpu_bind=\n options for \nsrun\n are \nrequired\n for hybrid jobs or jobs which do not utilize all physical cores \n\n\n\n\nSome source code\n\n\nInstrumented C code to measure AI\n\n\n// Code must be built with appropriate paths for VTune include file (ittnotify.h) and library (-littnotify)\n\n\n#include\n \nittnotify.h\n\n\n\n__SSC_MARK\n(\n0x111\n);\n \n// start SDE tracing, note it uses 2 underscores\n\n\n__itt_resume\n();\n \n// start VTune, again use 2 underscores\n\n\n\nfor\n \n(\nk\n=\n0\n;\n \nk\nNTIMES\n;\n \nk\n++\n)\n \n{\n\n \n#pragma omp parallel for\n\n \nfor\n \n(\nj\n=\n0\n;\n \nj\nSTREAM_ARRAY_SIZE\n;\n \nj\n++\n)\n\n \na\n[\nj\n]\n \n=\n \nb\n[\nj\n]\n+\nscalar\n*\nc\n[\nj\n];\n\n\n}\n\n\n\n__itt_pause\n();\n \n// stop VTune\n\n\n__SSC_MARK\n(\n0x222\n);\n \n// stop SDE tracing\n\n\n\n\n\nAnd some totally unrelated python code\n\n\ndef\n \ncount_cross_connections\n(\ncounts\n):\n\n    \nCounts is a list of the number of nodes in each (non-zero) group\n\n    \nreturn\n \nsum\n(\n \nx\n[\n0\n]\n*\nx\n[\n1\n]\n \nfor\n \nx\n \nin\n \nitertools\n.\ncombinations\n(\ncounts\n,\n \n2\n)\n \n)\n\n\n\n\n\nLaTex support\n\n\n\\[\n\\frac{n!}{k!(n-k)!} = \\binom{n}{k}\n\\]\nfrom:\n\n\n$$\n\\frac{n!}{k!(n-k)!} = \\binom{n}{k}\n$$\n\n\n\n\nImages\n\n\n\n\nInline HTML\n\n\nThis is probably best avoided if possible, but it works.\n\n\n\n  \nDefinition list\n\n  \nIs something people use sometimes.\n\n\n  \nMarkdown in HTML\n\n  \nDoes *not* work **very** well. Use HTML \ntags\n.", 
            "title": "Demo"
        }, 
        {
            "location": "/demo/demo/#welcome-to-nersc", 
            "text": "Welcome to the National Energy Research Scientific Computing Center, a high performance scientific computing center.\nThis document will guide you through the basics of using NERSC\u2019s supercomputers, storage systems, and services.", 
            "title": "Welcome to NERSC"
        }, 
        {
            "location": "/demo/demo/#what-is-nersc", 
            "text": "NERSC provides High Performance Computing and Storage facilities and support for research sponsored by, and of interest to, the U.S. Department of Energy Office of Science. NERSC has the unique programmatic role of supporting all six Office of Science program offices: Advanced Scientific Computing Research, Basic Energy Sciences, Biological and Environmental Research, Fusion Energy Sciences, High Energy Physics, and Nuclear Physics. Scientists who have been awarded research funding by any of the offices are eligible to apply for an allocation of NERSC time. Additional awards may be given to non-DOE funded project teams whose research is aligned with the Office of Science's mission. Allocations of time and storage are made by DOE.  NERSC is a national center, organizationally part of Lawrence Berkeley National Laboratory in Berkeley, CA. NERSC staff and facilities are primarily located at Berkeley Lab's Shyh Wang Hall on the Berkeley Lab campus.", 
            "title": "What is NERSC?"
        }, 
        {
            "location": "/demo/demo/#external-links", 
            "text": "OLCF  ALCF  NERSC", 
            "title": "External links"
        }, 
        {
            "location": "/demo/demo/#internal-links", 
            "text": "Portability definition   Tables:     System Type  Cray XC40      Theoretical Peak Performance (System)  31.4 PFlops    Theoretical Peak Performance (Haswell nodes)  2.3 PFlops    Theoretical Peak Performance (Xeon Phi nodes)  29.1 PFlops    Compute Nodes (Haswell)  2,388", 
            "title": "Internal links"
        }, 
        {
            "location": "/demo/demo/#include-scripts-source-code", 
            "text": "This site supports an include extension to Markdown.  One way to run a pure MPI job on Cori is  #!/bin/bash -l  #SBATCH -p debug  #SBATCH -N 64  #SBATCH -t 00:20:00  #SBATCH -J my_job  #SBATCH -L SCRATCH  #SBATCH -C haswell  # an extra -c 2 flag is optional for fully packed pure MPI \nsrun -n  2048  ./mycode.exe   Warning  The  -c  and  --cpu_bind=  options for  srun  are  required  for hybrid jobs or jobs which do not utilize all physical cores", 
            "title": "Include scripts/ source code"
        }, 
        {
            "location": "/demo/demo/#some-source-code", 
            "text": "Instrumented C code to measure AI  // Code must be built with appropriate paths for VTune include file (ittnotify.h) and library (-littnotify)  #include   ittnotify.h  __SSC_MARK ( 0x111 );   // start SDE tracing, note it uses 2 underscores  __itt_resume ();   // start VTune, again use 2 underscores  for   ( k = 0 ;   k NTIMES ;   k ++ )   { \n  #pragma omp parallel for \n  for   ( j = 0 ;   j STREAM_ARRAY_SIZE ;   j ++ ) \n  a [ j ]   =   b [ j ] + scalar * c [ j ];  }  __itt_pause ();   // stop VTune  __SSC_MARK ( 0x222 );   // stop SDE tracing   And some totally unrelated python code  def   count_cross_connections ( counts ): \n     Counts is a list of the number of nodes in each (non-zero) group \n     return   sum (   x [ 0 ] * x [ 1 ]   for   x   in   itertools . combinations ( counts ,   2 )   )", 
            "title": "Some source code"
        }, 
        {
            "location": "/demo/demo/#latex-support", 
            "text": "\\[\n\\frac{n!}{k!(n-k)!} = \\binom{n}{k}\n\\] from:  $$\n\\frac{n!}{k!(n-k)!} = \\binom{n}{k}\n$$", 
            "title": "LaTex support"
        }, 
        {
            "location": "/demo/demo/#images", 
            "text": "", 
            "title": "Images"
        }, 
        {
            "location": "/demo/demo/#inline-html", 
            "text": "This is probably best avoided if possible, but it works.  \n   Definition list \n   Is something people use sometimes. \n\n   Markdown in HTML \n   Does *not* work **very** well. Use HTML  tags .", 
            "title": "Inline HTML"
        }
    ]
}