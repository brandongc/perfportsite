{
    "docs": [
        {
            "location": "/", 
            "text": "Portability Across DOE Office of Science HPC Facilities\n\n\nAs the HPC community prepares for exascale and the semiconductor industry approaches the end of Moore's Law in terms of transistor size, we have entered a \nperiod of time of increased diversity in computer architecture for HPC with relatively new designs joining mature x86, DDR standard processor and memory \ntechnologies. These technologies include GPUs, Many Core Processors, ARM, FPGA and ASICs as well as new memory technology in the form of High Bandwidth \nMemory (HBM) often incorporated on the processor die as well as Non-Volatile memory (NVRAM) and Solid-State Disk (SSD) technology for accelerated IO. \n\n\nThe DOE Office of Science operates three world leading HPC facilities located at the Argonne Leadership Computing Facility (ALCF), National Energy Research \nScienctifc Computing Center (NERSC) at Lawrence Berkeley Lab and the Oak Ridge Leadership Computing Center (OLCF). These facilities field three of the most \npowerful supercomputers in world used by scientists throughout the DOE Office of Science and the world solving a \nnumber of important science problem in domains from materials science and chemistry to nuclear, particle and astrophysics. \n\n\nThese facilities have begun the transition for DOE users to energy-efficient like architectures. The facilities are currently fielding \nsystems with two-distinct \"pre-exascale\" like architectures that we discuss in detail on the subsequent pages: \n\n\n\n\n\n\n\n\nSystem\n\n\nTitan\n\n\n\n\n\n\n\n\n\n\nLocation\n\n\nOLCF\n\n\n\n\n\n\nArchitecture\n\n\nCPU + NVIDIA GPU\n\n\n\n\n\n\nScale\n\n\n18,688 Nodes\n\n\n\n\n\n\nPicture\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSystem\n\n\nCori\n\n\n\n\n\n\n\n\n\n\nLocation\n\n\nNERSC\n\n\n\n\n\n\nArchitecture\n\n\nXeon-Phi\n\n\n\n\n\n\nScale\n\n\n9688 Nodes\n\n\n\n\n\n\nNotes\n\n\nSSD Burst-Buffer IO layer\n\n\n\n\n\n\nPicture\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSystem\n\n\nTheta\n\n\n\n\n\n\n\n\n\n\nLocation\n\n\nALCF\n\n\n\n\n\n\nArchitecture\n\n\nXeon-Phi\n\n\n\n\n\n\nScale\n\n\n3624 Nodes\n\n\n\n\n\n\nPicture\n\n\n\n\n\n\n\n\n\n\nThe two processor architectures deployed on these systems are the CPU+NVidia GPU hybrid architecture on Titan and the \"self-hosted\" Xeon-Phi processors \n(code named \"Knights Landing\"). These two architectures, while seemingly quite different at first appearance, have a number of similarities that we believe \nrepresent general trends in exascale like architectures:\n\n\n\n\nIncrease parallelism (Cores, Threads, Warps/Blocks)\n\n\nVectorization (AVX512, 32 Wide Warps)\n\n\nSmall Amount High-bandwidth Coupled with Large Amounts of Traditional DDR\n\n\n\n\nWhile the details of the architectures are distinct and vendor specific programming libraries/languages (CUDA, AVX512 Intrinsics etc.) exist to address \nspecific architecture features; the commonalities are significant that a number of portable programming approaches exist for writing code that supports both \narchitectures. \n\n\nThis living website is intended to be a guide for applications teams targetting systems at multiple DOE office of science facilities. In the below pages, we \ndiscuss in detail the differences between the systems, the software environment and job-submission process. We discuss how to define and measure performacne \nportability and we provide recommendations and case studies for the most promising performance-portability pogramming approaches.\n\n\nAs an additional valuable resource, the Centers of Excellence from DOE facilities in both the Office of Science and the National Nuclear Security Agency \n(NNSA) have coordinated an annual meeting with a detailed report of findings available \nhere\n).", 
            "title": "Introduction"
        }, 
        {
            "location": "/#portability-across-doe-office-of-science-hpc-facilities", 
            "text": "As the HPC community prepares for exascale and the semiconductor industry approaches the end of Moore's Law in terms of transistor size, we have entered a \nperiod of time of increased diversity in computer architecture for HPC with relatively new designs joining mature x86, DDR standard processor and memory \ntechnologies. These technologies include GPUs, Many Core Processors, ARM, FPGA and ASICs as well as new memory technology in the form of High Bandwidth \nMemory (HBM) often incorporated on the processor die as well as Non-Volatile memory (NVRAM) and Solid-State Disk (SSD) technology for accelerated IO.   The DOE Office of Science operates three world leading HPC facilities located at the Argonne Leadership Computing Facility (ALCF), National Energy Research \nScienctifc Computing Center (NERSC) at Lawrence Berkeley Lab and the Oak Ridge Leadership Computing Center (OLCF). These facilities field three of the most \npowerful supercomputers in world used by scientists throughout the DOE Office of Science and the world solving a \nnumber of important science problem in domains from materials science and chemistry to nuclear, particle and astrophysics.   These facilities have begun the transition for DOE users to energy-efficient like architectures. The facilities are currently fielding \nsystems with two-distinct \"pre-exascale\" like architectures that we discuss in detail on the subsequent pages:      System  Titan      Location  OLCF    Architecture  CPU + NVIDIA GPU    Scale  18,688 Nodes    Picture         System  Cori      Location  NERSC    Architecture  Xeon-Phi    Scale  9688 Nodes    Notes  SSD Burst-Buffer IO layer    Picture         System  Theta      Location  ALCF    Architecture  Xeon-Phi    Scale  3624 Nodes    Picture      The two processor architectures deployed on these systems are the CPU+NVidia GPU hybrid architecture on Titan and the \"self-hosted\" Xeon-Phi processors \n(code named \"Knights Landing\"). These two architectures, while seemingly quite different at first appearance, have a number of similarities that we believe \nrepresent general trends in exascale like architectures:   Increase parallelism (Cores, Threads, Warps/Blocks)  Vectorization (AVX512, 32 Wide Warps)  Small Amount High-bandwidth Coupled with Large Amounts of Traditional DDR   While the details of the architectures are distinct and vendor specific programming libraries/languages (CUDA, AVX512 Intrinsics etc.) exist to address \nspecific architecture features; the commonalities are significant that a number of portable programming approaches exist for writing code that supports both \narchitectures.   This living website is intended to be a guide for applications teams targetting systems at multiple DOE office of science facilities. In the below pages, we \ndiscuss in detail the differences between the systems, the software environment and job-submission process. We discuss how to define and measure performacne \nportability and we provide recommendations and case studies for the most promising performance-portability pogramming approaches.  As an additional valuable resource, the Centers of Excellence from DOE facilities in both the Office of Science and the National Nuclear Security Agency \n(NNSA) have coordinated an annual meeting with a detailed report of findings available  here ).", 
            "title": "Portability Across DOE Office of Science HPC Facilities"
        }, 
        {
            "location": "/facilities/overview/", 
            "text": "This should be high level overview of differences at centers - we can then cover more in comparison\n\n\nThe \nAdvanced Scientific Computing Research\n\nprogram in DOE Office of Science sponsors three computing facilities - \nthe\nArgonne Leadership Computing Facility\n (ALCF), the\n\nOak Ridge Leadership Computing Facility\n (OLCF),\nand the \nNational Energy Research Scientific Computing\nCenter\n (NERSC). Below we summarize the technical\nspecifications of the current or upcoming computing systems deployed at each\nfacility.\n\n\n\n\n\n\n\n\nSystem\n\n\nFacility\n\n\nModel\n\n\nProcessor\n\n\nAccelerator\n\n\nNodes\n\n\nPerf. Per Node\n\n\nPeak Perf.\n\n\n\n\n\n\n\n\n\n\nAurora\n\n\nALCF\n\n\nIntel\n\n\nIntel Xeon Phi (3\nrd\n gen)\n\n\n(none)\n\n\n50 000\n\n\n?\n\n\n?\n\n\n\n\n\n\nCori\n\n\nNERSC\n\n\nCray XC40\n\n\nIntel Xeon Phi (2\nnd\n gen)\n\n\n(none)\n\n\n9 688\n\n\n2.6 TF\n\n\n30 PF\n\n\n\n\n\n\nSummit\n\n\nOLCF\n\n\nIBM\n\n\nIBM POWER9\n\n\nNVIDIA Tesla (\"Volta\")\n\n\n~4 600\n\n\n 40 TF\n\n\n?\n\n\n\n\n\n\nTheta\n\n\nALCF\n\n\nCray XC40\n\n\nIntel Xeon Phi (2\nnd\n gen)\n\n\n(none)\n\n\n3 624\n\n\n2.6 TF\n\n\n10 PF\n\n\n\n\n\n\nTitan\n\n\nOLCF\n\n\nCray XK7\n\n\nAMD Opteron (\"Interlagos\")\n\n\nNVIDIA Tesla (\"Kepler\")\n\n\n18 688\n\n\n1.4 TF\n\n\n27 PF", 
            "title": "Overview"
        }, 
        {
            "location": "/facilities/overview/#this-should-be-high-level-overview-of-differences-at-centers-we-can-then-cover-more-in-comparison", 
            "text": "The  Advanced Scientific Computing Research \nprogram in DOE Office of Science sponsors three computing facilities -  the\nArgonne Leadership Computing Facility  (ALCF), the Oak Ridge Leadership Computing Facility  (OLCF),\nand the  National Energy Research Scientific Computing\nCenter  (NERSC). Below we summarize the technical\nspecifications of the current or upcoming computing systems deployed at each\nfacility.     System  Facility  Model  Processor  Accelerator  Nodes  Perf. Per Node  Peak Perf.      Aurora  ALCF  Intel  Intel Xeon Phi (3 rd  gen)  (none)  50 000  ?  ?    Cori  NERSC  Cray XC40  Intel Xeon Phi (2 nd  gen)  (none)  9 688  2.6 TF  30 PF    Summit  OLCF  IBM  IBM POWER9  NVIDIA Tesla (\"Volta\")  ~4 600   40 TF  ?    Theta  ALCF  Cray XC40  Intel Xeon Phi (2 nd  gen)  (none)  3 624  2.6 TF  10 PF    Titan  OLCF  Cray XK7  AMD Opteron (\"Interlagos\")  NVIDIA Tesla (\"Kepler\")  18 688  1.4 TF  27 PF", 
            "title": "This should be high level overview of differences at centers - we can then cover more in comparison"
        }, 
        {
            "location": "/facilities/tools/", 
            "text": "Performance Analysis Tools\n\n\nEvaluating application performance portability across diverse computing\narchitectures often requires the aid of performance analysis tools. Such tools\nprovide detailed information and statistics characterizing an application's\nusage of the architecture, and can guide the developer as she optimizes\nbottlenecks to achieve higher performance.\n\n\nEach ASCR facility is equipped with a wide range of tools for measuring\napplication performance. The applications running at the three facilities\nexhibit a broad range of demands from computer architectures - some are limited\nby memory bandwidth, others by latency, and others still by the CPU itself. The\nperformance measurement tools available at the ASCR facilities can measure in\ndetail how an application uses each of these resources. They include, but are\nnot limited to, the list provided below. The description of each tool is copied\nfrom its official documentation.\n\n\n\n\nAllinea MAP\n:\n  Allinea MAP is the profiler for parallel, multithreaded or single threaded C,\n  C++, Fortran and F90 codes. It provides in depth analysis and bottleneck\n  pinpointing to the source line.\n\n\nCray Performance Measurement and Analysis\n  Tools\n:\n  The Cray Performance Measurement and Analysis Tools (or CrayPat) are a suite\n  of utilities that enable the user to capture and analyze performance data\n  generated during the execution of a program on a Cray system. The information\n  collected and analysis produced by use of these tools can help the user to\n  find answers to two fundamental programming questions: \nHow fast is my\n  program running?\n and \nHow can I make it run faster?\n\n\nIntel Advisor\n:\n  Intel Advisor is used early in the process of adding vectorization into your\n  code, or while converting parts of a serial program to a parallel\n  (multithreaded) program. It helps you explore and locate areas in which the\n  optimizations might provide significant benefit. It also helps you predict the\n  costs and benefits of adding vectorization or parallelism to those parts of\n  your program, allowing you to experiment.\n\n\nIntel VTune Amplifier\n:\n  Intel VTune Amplifier is a performance analysis tool targeted for users\n  developing serial and multithreaded applications.\n\n\nnvprof\n:\n  nvprof enables the collection of a timeline of CUDA-related activities on both\n  CPU and GPU, including kernel execution, memory transfers, memory set and CUDA\n  API calls and events or metrics for CUDA kernels.\n\n\nTuning and Analysis Utilities (TAU)\n:\n  TAU Performance System is a portable profiling and tracing toolkit for\n  performance analysis of parallel programs written in Fortran, C, C++, UPC,\n  Java, Python.", 
            "title": "Tools"
        }, 
        {
            "location": "/facilities/tools/#performance-analysis-tools", 
            "text": "Evaluating application performance portability across diverse computing\narchitectures often requires the aid of performance analysis tools. Such tools\nprovide detailed information and statistics characterizing an application's\nusage of the architecture, and can guide the developer as she optimizes\nbottlenecks to achieve higher performance.  Each ASCR facility is equipped with a wide range of tools for measuring\napplication performance. The applications running at the three facilities\nexhibit a broad range of demands from computer architectures - some are limited\nby memory bandwidth, others by latency, and others still by the CPU itself. The\nperformance measurement tools available at the ASCR facilities can measure in\ndetail how an application uses each of these resources. They include, but are\nnot limited to, the list provided below. The description of each tool is copied\nfrom its official documentation.   Allinea MAP :\n  Allinea MAP is the profiler for parallel, multithreaded or single threaded C,\n  C++, Fortran and F90 codes. It provides in depth analysis and bottleneck\n  pinpointing to the source line.  Cray Performance Measurement and Analysis\n  Tools :\n  The Cray Performance Measurement and Analysis Tools (or CrayPat) are a suite\n  of utilities that enable the user to capture and analyze performance data\n  generated during the execution of a program on a Cray system. The information\n  collected and analysis produced by use of these tools can help the user to\n  find answers to two fundamental programming questions:  How fast is my\n  program running?  and  How can I make it run faster?  Intel Advisor :\n  Intel Advisor is used early in the process of adding vectorization into your\n  code, or while converting parts of a serial program to a parallel\n  (multithreaded) program. It helps you explore and locate areas in which the\n  optimizations might provide significant benefit. It also helps you predict the\n  costs and benefits of adding vectorization or parallelism to those parts of\n  your program, allowing you to experiment.  Intel VTune Amplifier :\n  Intel VTune Amplifier is a performance analysis tool targeted for users\n  developing serial and multithreaded applications.  nvprof :\n  nvprof enables the collection of a timeline of CUDA-related activities on both\n  CPU and GPU, including kernel execution, memory transfers, memory set and CUDA\n  API calls and events or metrics for CUDA kernels.  Tuning and Analysis Utilities (TAU) :\n  TAU Performance System is a portable profiling and tracing toolkit for\n  performance analysis of parallel programs written in Fortran, C, C++, UPC,\n  Java, Python.", 
            "title": "Performance Analysis Tools"
        }, 
        {
            "location": "/facilities/comparison/", 
            "text": "", 
            "title": "Comparison"
        }, 
        {
            "location": "/facilities/resources/", 
            "text": "Jack / Bronson / Tim to Write", 
            "title": "Resources"
        }, 
        {
            "location": "/perfport/definition/", 
            "text": "Jack To Write", 
            "title": "Definition"
        }, 
        {
            "location": "/perfport/measurements/", 
            "text": "Measuring Performance Portability\n\n\nAs discussed in the previous section, performance portability can be an elusive topic to quantify \nand different engineers often provide different definitions or measurement techniques.\n\n\nMeasuring 'portability' itself is somewhat more well defined. One can, in principle, measure the \ntotal lines of code used in common across different architectures vs. the amount of code intended \nfor a single architecture via \nIFDEF\n pre-processing statements and the like. A code with 0% \narchitecture specfic code being completely portable and a code with a 100% architecture specific \ncode being essentially made up of multiple applications. \n\n\n'Performance', even on a single architecture, is a bit less simple to define and measure. In \npractice, scientists generally care about the quality and quantity of scientific output they \nproduce. This typically maps for them to relative performance concepts, such as how much faster \ncan a particular run or set of runs run today than yesterday or on this machine than that. The \ndrawback of trying to measure performance in this way is that the baseline is arbitrary - i.e. you \ndon't know how well your code is performing on any architecture compared to how it 'should' be \nperforming if it were well optimized.\n\n\nOne may \nin principle define absolute performance as a measure of", 
            "title": "Measurements"
        }, 
        {
            "location": "/perfport/measurements/#measuring-performance-portability", 
            "text": "As discussed in the previous section, performance portability can be an elusive topic to quantify \nand different engineers often provide different definitions or measurement techniques.  Measuring 'portability' itself is somewhat more well defined. One can, in principle, measure the \ntotal lines of code used in common across different architectures vs. the amount of code intended \nfor a single architecture via  IFDEF  pre-processing statements and the like. A code with 0% \narchitecture specfic code being completely portable and a code with a 100% architecture specific \ncode being essentially made up of multiple applications.   'Performance', even on a single architecture, is a bit less simple to define and measure. In \npractice, scientists generally care about the quality and quantity of scientific output they \nproduce. This typically maps for them to relative performance concepts, such as how much faster \ncan a particular run or set of runs run today than yesterday or on this machine than that. The \ndrawback of trying to measure performance in this way is that the baseline is arbitrary - i.e. you \ndon't know how well your code is performing on any architecture compared to how it 'should' be \nperforming if it were well optimized.  One may \nin principle define absolute performance as a measure of", 
            "title": "Measuring Performance Portability"
        }, 
        {
            "location": "/perfport/libraries/", 
            "text": "Libraries e.g. BLAS/FFT, MAGMA, CULA, Trillinos, PETSc\n\n\nPros\n\n\n\n\n\n\nOften encapsulate much of the computational intensity found in scientific codes\n\n\n\n\n\n\nCan allow immediate portability under some circumstances\n\n\n\n\n\n\nPerformance becomes a task for library authors/maintainers\n\n\n\n\n\n\nCons\n\n\n\n\n\n\nLimited set of portable libraries at present\n\n\n\n\n\n\nMay not capture all the important/expensive tasks in a given code  \n\n\n\n\n\n\nOften require recasting data structures to match library requirements\n\n\n\n\n\n\nOpaque interior threading models", 
            "title": "Libraries"
        }, 
        {
            "location": "/perfport/directives/", 
            "text": "Directives\n\n\nPros \n\n\n\n\n\n\nAvailable for many different languages \n\n\n\n\n\n\nGood control of execution \n\n\n\n\n\n\nAllow performance optimization\n\n\n\n\n\n\nControlled by well-defined standards bodies\n\n\n\n\n\n\nCons \n\n\n\n\n\n\nRequire compiler support \n\n\n\n\n\n\nEvolving standards", 
            "title": "Directives"
        }, 
        {
            "location": "/perfport/directives/#directives", 
            "text": "Pros     Available for many different languages     Good control of execution     Allow performance optimization    Controlled by well-defined standards bodies    Cons     Require compiler support     Evolving standards", 
            "title": "Directives"
        }, 
        {
            "location": "/perfport/frameworks/", 
            "text": "Frameworks e.g. Kokkos, RAJA\n\n\nPros \n\n\n\n\n\n\nProvide good portability through the use of platform-dependent back-ends\n\n\n\n\n\n\nPromote good programming practices\n\n\n\n\n\n\nCons\n\n\n\n\n\n\nGenerally C++ only (at present)\n\n\n\n\n\n\nDo not represent recognized standards(yet)\n\n\n\n\n\n\nEvolving quickly", 
            "title": "Frameworks"
        }, 
        {
            "location": "/perfport/frameworks/#frameworks-eg-kokkos-raja", 
            "text": "Pros     Provide good portability through the use of platform-dependent back-ends    Promote good programming practices    Cons    Generally C++ only (at present)    Do not represent recognized standards(yet)    Evolving quickly", 
            "title": "Frameworks e.g. Kokkos, RAJA"
        }, 
        {
            "location": "/perfport/dsl/", 
            "text": "", 
            "title": "DSL"
        }, 
        {
            "location": "/perfport/models/", 
            "text": "Kokkos\n\n\nKokkos\n implements a programming model in\nC++ for writing performance portable applications targeting all major HPC\nplatforms. For that purpose it provides abstractions for both parallel\nexecution of code and data management. Kokkos is designed to target complex\nnode architectures with N-level memory hierarchies and multiple types of\nexecution resources. It currently can use OpenMP, Pthreads and CUDA as backend\nprogramming models. (\nText provided by \nREADME\n in Kokkos source code repository\n).\n\n\nKokkos provides two types of abstraction which insulate the application\ndeveloper from the details of expressing parallelism on a particular\narchitecture. One is a \"memory space\", which characterizes where data resides\nin memory, e.g., in high-bandwidth memory, in DRAM, on GPU memory, etc. The\nother type is an \"execution space\", which describes how execution of a kernel\nis parallelized.\n\n\nIn terms of implementation, Kokkos expresses its memory and execution spaces\nvia templated C++ code. One constructs memory spaces through \"Views\", which are\ntemplated multi-dimensional arrays. One then issues an execution policy on the\ndata. The following snippet shows matrix-vector multiplication using Kokkos\nviews and a \"reduction\" execution policy. It is taken from the Kokkos \nGTC2017\ntutorial\n#2\n.\n\n\n  \nKokkos\n::\nView\ndouble\n*\n  \nx\n(\n \nx\n,\n \n128\n \n);\n \n// a vector of length 128\n\n  \nKokkos\n::\nView\ndouble\n**\n \nA\n(\n \nA\n,\n \n128\n,\n \n128\n \n);\n \n// a matrix of size 128^2\n\n\n  \nKokkos\n::\nparallel_reduce\n(\n \nN\n,\n \nKOKKOS_LAMBDA\n \n(\n \nint\n \nj\n,\n \ndouble\n \nupdate\n \n)\n \n{\n\n    \ndouble\n \ntemp2\n \n=\n \n0\n;\n\n    \nfor\n \n(\n \nint\n \ni\n \n=\n \n0\n;\n \ni\n \n \nM\n;\n \n++\ni\n \n)\n \n{\n\n      \ntemp2\n \n+=\n \nA\n(\n \nj\n,\n \ni\n \n)\n \n*\n \nx\n(\n \ni\n \n);\n\n    \n}\n\n    \nupdate\n \n+=\n \ny\n(\n \nj\n \n)\n \n*\n \ntemp2\n;\n\n  \n},\n \nresult\n \n);", 
            "title": "Models"
        }, 
        {
            "location": "/perfport/models/#kokkos", 
            "text": "Kokkos  implements a programming model in\nC++ for writing performance portable applications targeting all major HPC\nplatforms. For that purpose it provides abstractions for both parallel\nexecution of code and data management. Kokkos is designed to target complex\nnode architectures with N-level memory hierarchies and multiple types of\nexecution resources. It currently can use OpenMP, Pthreads and CUDA as backend\nprogramming models. ( Text provided by  README  in Kokkos source code repository ).  Kokkos provides two types of abstraction which insulate the application\ndeveloper from the details of expressing parallelism on a particular\narchitecture. One is a \"memory space\", which characterizes where data resides\nin memory, e.g., in high-bandwidth memory, in DRAM, on GPU memory, etc. The\nother type is an \"execution space\", which describes how execution of a kernel\nis parallelized.  In terms of implementation, Kokkos expresses its memory and execution spaces\nvia templated C++ code. One constructs memory spaces through \"Views\", which are\ntemplated multi-dimensional arrays. One then issues an execution policy on the\ndata. The following snippet shows matrix-vector multiplication using Kokkos\nviews and a \"reduction\" execution policy. It is taken from the Kokkos  GTC2017\ntutorial\n#2 .     Kokkos :: View double *    x (   x ,   128   );   // a vector of length 128 \n   Kokkos :: View double **   A (   A ,   128 ,   128   );   // a matrix of size 128^2 \n\n   Kokkos :: parallel_reduce (   N ,   KOKKOS_LAMBDA   (   int   j ,   double   update   )   { \n     double   temp2   =   0 ; \n     for   (   int   i   =   0 ;   i     M ;   ++ i   )   { \n       temp2   +=   A (   j ,   i   )   *   x (   i   ); \n     } \n     update   +=   y (   j   )   *   temp2 ; \n   },   result   );", 
            "title": "Kokkos"
        }, 
        {
            "location": "/perfport/summary/", 
            "text": "This will be a comparison of all the approaches we tried.\n\n\n\n\n\n\n\n\nApproach\n\n\nBenefits\n\n\nChallenges\n\n\n\n\n\n\n\n\n\n\nOpenMP 4.5\n\n\nSupport for C, C++, Fortran\n\n\nreliant on quality of compiler implementation\n\n\n\n\n\n\nKokkos\n\n\n\n\n\n\n\n\n\n\nRAJA", 
            "title": "Summary"
        }, 
        {
            "location": "/case_studies/amr/overview/", 
            "text": "Thorsten / Brian to Write\n\n\nOverview of BoxLib/AMReX\n\n\nBoxLib\n is a framework for developing\nparallel, block-structured, adaptive mesh refinement (AMR) applications. It is\nwritten primarily in C++, and enables scientific application development\nthrough compute kernels written primarily in Fortran. Through the \nExascale\nComputing Project\n's\n\nBlock Structured Adaptive Mesh Refinement Co-Design\nCenter\n,\nBoxLib has since been superseded by\n\nAMReX\n. Both frameworks are publicly\navailable. The DOE COE for Performance Portability began prior to the formation\nof the Co-Design Center; consequently,the efforts described here focus on\nBoxLib, although the functionality described here is largely the same between\nthe two frameworks.\n\n\nBoxLib contains a wide variety of functionality:\n\n\n\n\nboundary condition exchange among boxes\n\n\nload balancing through regridding boxes among MPI processes\n\n\nmetadata operations such as computing volume intersections among boxes\n\n\nmemory management through pool allocators\n\n\n\n\nIn addition these, BoxLib also provides linear solvers which use geometric\nmultigrid methods to solve problems on both cell-centered and nodal data. Our\nperformance portability efforts described here focus on the cell-centered\nsolver, which is algorithmically simpler than the nodal solver.", 
            "title": "Overview"
        }, 
        {
            "location": "/case_studies/amr/overview/#overview-of-boxlibamrex", 
            "text": "BoxLib  is a framework for developing\nparallel, block-structured, adaptive mesh refinement (AMR) applications. It is\nwritten primarily in C++, and enables scientific application development\nthrough compute kernels written primarily in Fortran. Through the  Exascale\nComputing Project 's Block Structured Adaptive Mesh Refinement Co-Design\nCenter ,\nBoxLib has since been superseded by AMReX . Both frameworks are publicly\navailable. The DOE COE for Performance Portability began prior to the formation\nof the Co-Design Center; consequently,the efforts described here focus on\nBoxLib, although the functionality described here is largely the same between\nthe two frameworks.  BoxLib contains a wide variety of functionality:   boundary condition exchange among boxes  load balancing through regridding boxes among MPI processes  metadata operations such as computing volume intersections among boxes  memory management through pool allocators   In addition these, BoxLib also provides linear solvers which use geometric\nmultigrid methods to solve problems on both cell-centered and nodal data. Our\nperformance portability efforts described here focus on the cell-centered\nsolver, which is algorithmically simpler than the nodal solver.", 
            "title": "Overview of BoxLib/AMReX"
        }, 
        {
            "location": "/case_studies/amr/parallelism/", 
            "text": "Parallelization\n\n\nBoxLib implements parallelization through a hybrid MPI+OpenMP approach.\n\n\nMPI\n\n\nAt the coarsest level, BoxLib decomposes the problem domain into rectangular\nboxes, and distributes these among MPI processes. Each process follows an\n\"owner computes\" model, wherein it loops over its own boxes, executing Fortran\nkernels on each box in series. An example is shown in the figure below, where\nthe red and green boxes are assigned to the same MPI process.\n\n\n\n\nOpenMP\n\n\nBoxLib adds an additional layer of parallelism within each MPI process through\nOpenMP threading, specifically by decomposing its set of boxes into a set of\nsmaller \"tiles\", which are then distributed among OpenMP threads. Although\nthese tiles can be arbitrarily shaped, by default they are pencil-shaped, being\nlong in the stride-1 memory access dimension (the x-dimension in Fortran\nkernels), and short in the other two dimensions, in order to attain high cache\nreuse and optimal hardware memory prefetching. As with the MPI parallelism, the\nOpenMP tile box parallelism also follows an \"owner computes\" model, but at the\nfiner-grained thread level, rather than at the process level.\n\n\nThis OpenMP parallelism is illustrated in the figure below. The box\ndistribution is the same as in the figure above, except in this case each box\nis further decomposed into smaller tiles. BoxLib then builds a list of all\ntiles comprising all boxes owned by a given MPI process, and distributes the\nlist among the OpenMP threads in the process. The figure below illustrates this\nprocess by color-coding each tile, with unique threads assigned to each color,\nsuch that the same thread may operate on tiles spanning different boxes. This\napproach avoids unnecessary thread synchronization which would occur if threads\nwere distributed among tiles within each box.\n\n\n\n\nThe figures on this page are taken from the AMReX User's Guide.", 
            "title": "Parallelism"
        }, 
        {
            "location": "/case_studies/amr/parallelism/#parallelization", 
            "text": "BoxLib implements parallelization through a hybrid MPI+OpenMP approach.", 
            "title": "Parallelization"
        }, 
        {
            "location": "/case_studies/amr/parallelism/#mpi", 
            "text": "At the coarsest level, BoxLib decomposes the problem domain into rectangular\nboxes, and distributes these among MPI processes. Each process follows an\n\"owner computes\" model, wherein it loops over its own boxes, executing Fortran\nkernels on each box in series. An example is shown in the figure below, where\nthe red and green boxes are assigned to the same MPI process.", 
            "title": "MPI"
        }, 
        {
            "location": "/case_studies/amr/parallelism/#openmp", 
            "text": "BoxLib adds an additional layer of parallelism within each MPI process through\nOpenMP threading, specifically by decomposing its set of boxes into a set of\nsmaller \"tiles\", which are then distributed among OpenMP threads. Although\nthese tiles can be arbitrarily shaped, by default they are pencil-shaped, being\nlong in the stride-1 memory access dimension (the x-dimension in Fortran\nkernels), and short in the other two dimensions, in order to attain high cache\nreuse and optimal hardware memory prefetching. As with the MPI parallelism, the\nOpenMP tile box parallelism also follows an \"owner computes\" model, but at the\nfiner-grained thread level, rather than at the process level.  This OpenMP parallelism is illustrated in the figure below. The box\ndistribution is the same as in the figure above, except in this case each box\nis further decomposed into smaller tiles. BoxLib then builds a list of all\ntiles comprising all boxes owned by a given MPI process, and distributes the\nlist among the OpenMP threads in the process. The figure below illustrates this\nprocess by color-coding each tile, with unique threads assigned to each color,\nsuch that the same thread may operate on tiles spanning different boxes. This\napproach avoids unnecessary thread synchronization which would occur if threads\nwere distributed among tiles within each box.   The figures on this page are taken from the AMReX User's Guide.", 
            "title": "OpenMP"
        }, 
        {
            "location": "/case_studies/amr/code_layout/", 
            "text": "Code Layout\n\n\nThe typical form of a BoxLib application is a C++ \"driver\" code which manages\nthe boxes on the domain, and calls Fortran kernels in a loop over the boxes\nowned by each MPI process. An example of this layout is shown below:\n\n\n// Advance the solution one grid at a time\n\n\nfor\n \n(\n \nMFIter\n \nmfi\n(\nold_phi\n);\n \nmfi\n.\nisValid\n();\n \n++\nmfi\n \n)\n\n\n{\n\n  \nconst\n \nBox\n \nbx\n \n=\n \nmfi\n.\nvalidbox\n();\n\n\n  \nupdate_phi\n(\nold_phi\n[\nmfi\n].\ndataPtr\n(),\n\n             \nnew_phi\n[\nmfi\n].\ndataPtr\n(),\n\n             \nng_p\n,\n\n             \nflux\n[\n0\n][\nmfi\n].\ndataPtr\n(),\n\n             \nflux\n[\n1\n][\nmfi\n].\ndataPtr\n(),\n\n             \nflux\n[\n2\n][\nmfi\n].\ndataPtr\n(),\n\n             \nng_f\n,\n \nbx\n.\nloVect\n(),\n \nbx\n.\nhiVect\n(),\n \ndx\n[\n0\n],\n \ndt\n);\n\n  \n}\n\n\n}\n\n\n\n\n\nHere the \nMFIter\n object is an iterator over boxes owned by an MPI process. The\n\nBox\n object contains the geometric metadata describing a particular box, e.g.,\nthe indices of the lower and upper corners. The variables \nold_phi\n, \nnew_phi\n,\nand \nflux\n contain pointers to the arrays which contain the floating point data\non the grid. The \nupdate_phi\n function is a Fortran function which uses the\ndata from the \nBox\n object to construct 3-D loops over the appropriate section\nof the three floating-point arrays. The function may look like the following:\n\n\nsubroutine \nupdate_phi\n(\nphiold\n,\n \nphinew\n,\n \nng_p\n,\n \nfluxx\n,\n \nfluxy\n,\n \nfluxz\n,\n \nng_f\n,\n \nlo\n,\n \nhi\n,\n \ndx\n,\n \ndt\n)\n \nbind\n(\nC\n,\n \nname\n=\nupdate_phi\n)\n\n\n  \ninteger\n          \n::\n \nlo\n(\n3\n),\n \nhi\n(\n3\n),\n \nng_p\n,\n \nng_f\n\n  \ndouble precision\n \n::\n \nphiold\n(\nlo\n(\n1\n)\n-\nng_p\n:\nhi\n(\n1\n)\n+\nng_p\n,\nlo\n(\n2\n)\n-\nng_p\n:\nhi\n(\n2\n)\n+\nng_p\n,\nlo\n(\n3\n)\n-\nng_p\n:\nhi\n(\n3\n)\n+\nng_p\n)\n\n  \ndouble precision\n \n::\n \nphinew\n(\nlo\n(\n1\n)\n-\nng_p\n:\nhi\n(\n1\n)\n+\nng_p\n,\nlo\n(\n2\n)\n-\nng_p\n:\nhi\n(\n2\n)\n+\nng_p\n,\nlo\n(\n3\n)\n-\nng_p\n:\nhi\n(\n3\n)\n+\nng_p\n)\n\n  \ndouble precision\n \n::\n  \nfluxx\n(\nlo\n(\n1\n)\n-\nng_f\n:\nhi\n(\n1\n)\n+\nng_f\n+\n1\n,\nlo\n(\n2\n)\n-\nng_f\n:\nhi\n(\n2\n)\n+\nng_f\n,\nlo\n(\n3\n)\n-\nng_f\n:\nhi\n(\n3\n)\n+\nng_f\n)\n\n  \ndouble precision\n \n::\n  \nfluxy\n(\nlo\n(\n1\n)\n-\nng_f\n:\nhi\n(\n1\n)\n+\nng_f\n,\nlo\n(\n2\n)\n-\nng_f\n:\nhi\n(\n2\n)\n+\nng_f\n+\n1\n,\nlo\n(\n3\n)\n-\nng_f\n:\nhi\n(\n3\n)\n+\nng_f\n)\n\n  \ndouble precision\n \n::\n  \nfluxz\n(\nlo\n(\n1\n)\n-\nng_f\n:\nhi\n(\n1\n)\n+\nng_f\n,\nlo\n(\n2\n)\n-\nng_f\n:\nhi\n(\n2\n)\n+\nng_f\n,\nlo\n(\n3\n)\n-\nng_f\n:\nhi\n(\n3\n)\n+\nng_f\n+\n1\n)\n\n  \ndouble precision\n \n::\n \ndx\n,\n \ndt\n\n\n  \ninteger \ni\n,\nj\n,\nk\n\n\n  \ndo \nk\n=\nlo\n(\n3\n),\nhi\n(\n3\n)\n\n     \ndo \nj\n=\nlo\n(\n2\n),\nhi\n(\n2\n)\n\n        \ndo \ni\n=\nlo\n(\n1\n),\nhi\n(\n1\n)\n\n\n           \nphinew\n(\ni\n,\nj\n,\nk\n)\n \n=\n \nphiold\n(\ni\n,\nj\n,\nk\n)\n \n+\n \ndt\n \n*\n \n\n                \n(\n \nfluxx\n(\ni\n+\n1\n,\nj\n,\nk\n)\n-\nfluxx\n(\ni\n,\nj\n,\nk\n)\n \n\n                \n+\nfluxy\n(\ni\n,\nj\n+\n1\n,\nk\n)\n-\nfluxy\n(\ni\n,\nj\n,\nk\n)\n \n\n                \n+\nfluxz\n(\ni\n,\nj\n,\nk\n+\n1\n)\n-\nfluxz\n(\ni\n,\nj\n,\nk\n)\n \n)\n \n/\n \ndx\n\n\n        \nend do\n\n\n     end do\n\n\n  end do\n\n\n\n\n\nThe Fortran function constructs the appropriate \"view\" into each box using the\ndata from the \nBox\n object from the C++ function, as well as from the number of\nghost zones (\nng_p\n for \nold_phi\n and \nnew_phi\n, and \nng_f\n for \nflux\n).\n\n\nThe above example demonstrates pure MPI parallelism; the analogous C++ code\nwhich uses OpenMP tiling as described above would look like the following:\n\n\n// Advance the solution one grid at a time\n\n\n#ifdef _OPENMP\n\n\n#pragma omp parallel\n\n\n#endif\n\n\nfor\n \n(\n \nMFIter\n \nmfi\n(\nold_phi\n,\ntrue\n);\n \nmfi\n.\nisValid\n();\n \n++\nmfi\n \n)\n\n\n{\n\n  \nconst\n \nBox\n \ntbx\n \n=\n \nmfi\n.\ntilebox\n();\n\n\n  \nupdate_phi\n(\nold_phi\n[\nmfi\n].\ndataPtr\n(),\n\n             \nnew_phi\n[\nmfi\n].\ndataPtr\n(),\n\n             \nng_p\n,\n\n             \nflux\n[\n0\n][\nmfi\n].\ndataPtr\n(),\n\n             \nflux\n[\n1\n][\nmfi\n].\ndataPtr\n(),\n\n             \nflux\n[\n2\n][\nmfi\n].\ndataPtr\n(),\n\n             \nng_f\n,\n \ntbx\n.\nloVect\n(),\n \ntbx\n.\nhiVect\n(),\n \ndx\n[\n0\n],\n \ndt\n);\n\n  \n}\n\n\n}\n\n\n\n\n\nThe OpenMP parallelism is coarse-grained; rather than constructing a large\n\nBox\n from \nmfi.validbox()\n, it constructs a smaller \nBox\n from\n\nmfi.tilebox()\n. The metadata format remains unchanged, allowing the Fortran\nfunction to remain unchanged as well.", 
            "title": "Code Layout"
        }, 
        {
            "location": "/case_studies/amr/code_layout/#code-layout", 
            "text": "The typical form of a BoxLib application is a C++ \"driver\" code which manages\nthe boxes on the domain, and calls Fortran kernels in a loop over the boxes\nowned by each MPI process. An example of this layout is shown below:  // Advance the solution one grid at a time  for   (   MFIter   mfi ( old_phi );   mfi . isValid ();   ++ mfi   )  { \n   const   Box   bx   =   mfi . validbox (); \n\n   update_phi ( old_phi [ mfi ]. dataPtr (), \n              new_phi [ mfi ]. dataPtr (), \n              ng_p , \n              flux [ 0 ][ mfi ]. dataPtr (), \n              flux [ 1 ][ mfi ]. dataPtr (), \n              flux [ 2 ][ mfi ]. dataPtr (), \n              ng_f ,   bx . loVect (),   bx . hiVect (),   dx [ 0 ],   dt ); \n   }  }   Here the  MFIter  object is an iterator over boxes owned by an MPI process. The Box  object contains the geometric metadata describing a particular box, e.g.,\nthe indices of the lower and upper corners. The variables  old_phi ,  new_phi ,\nand  flux  contain pointers to the arrays which contain the floating point data\non the grid. The  update_phi  function is a Fortran function which uses the\ndata from the  Box  object to construct 3-D loops over the appropriate section\nof the three floating-point arrays. The function may look like the following:  subroutine  update_phi ( phiold ,   phinew ,   ng_p ,   fluxx ,   fluxy ,   fluxz ,   ng_f ,   lo ,   hi ,   dx ,   dt )   bind ( C ,   name = update_phi ) \n\n   integer            ::   lo ( 3 ),   hi ( 3 ),   ng_p ,   ng_f \n   double precision   ::   phiold ( lo ( 1 ) - ng_p : hi ( 1 ) + ng_p , lo ( 2 ) - ng_p : hi ( 2 ) + ng_p , lo ( 3 ) - ng_p : hi ( 3 ) + ng_p ) \n   double precision   ::   phinew ( lo ( 1 ) - ng_p : hi ( 1 ) + ng_p , lo ( 2 ) - ng_p : hi ( 2 ) + ng_p , lo ( 3 ) - ng_p : hi ( 3 ) + ng_p ) \n   double precision   ::    fluxx ( lo ( 1 ) - ng_f : hi ( 1 ) + ng_f + 1 , lo ( 2 ) - ng_f : hi ( 2 ) + ng_f , lo ( 3 ) - ng_f : hi ( 3 ) + ng_f ) \n   double precision   ::    fluxy ( lo ( 1 ) - ng_f : hi ( 1 ) + ng_f , lo ( 2 ) - ng_f : hi ( 2 ) + ng_f + 1 , lo ( 3 ) - ng_f : hi ( 3 ) + ng_f ) \n   double precision   ::    fluxz ( lo ( 1 ) - ng_f : hi ( 1 ) + ng_f , lo ( 2 ) - ng_f : hi ( 2 ) + ng_f , lo ( 3 ) - ng_f : hi ( 3 ) + ng_f + 1 ) \n   double precision   ::   dx ,   dt \n\n   integer  i , j , k \n\n   do  k = lo ( 3 ), hi ( 3 ) \n      do  j = lo ( 2 ), hi ( 2 ) \n         do  i = lo ( 1 ), hi ( 1 ) \n\n            phinew ( i , j , k )   =   phiold ( i , j , k )   +   dt   *   \n                 (   fluxx ( i + 1 , j , k ) - fluxx ( i , j , k )   \n                 + fluxy ( i , j + 1 , k ) - fluxy ( i , j , k )   \n                 + fluxz ( i , j , k + 1 ) - fluxz ( i , j , k )   )   /   dx \n\n         end do       end do    end do   The Fortran function constructs the appropriate \"view\" into each box using the\ndata from the  Box  object from the C++ function, as well as from the number of\nghost zones ( ng_p  for  old_phi  and  new_phi , and  ng_f  for  flux ).  The above example demonstrates pure MPI parallelism; the analogous C++ code\nwhich uses OpenMP tiling as described above would look like the following:  // Advance the solution one grid at a time  #ifdef _OPENMP  #pragma omp parallel  #endif  for   (   MFIter   mfi ( old_phi , true );   mfi . isValid ();   ++ mfi   )  { \n   const   Box   tbx   =   mfi . tilebox (); \n\n   update_phi ( old_phi [ mfi ]. dataPtr (), \n              new_phi [ mfi ]. dataPtr (), \n              ng_p , \n              flux [ 0 ][ mfi ]. dataPtr (), \n              flux [ 1 ][ mfi ]. dataPtr (), \n              flux [ 2 ][ mfi ]. dataPtr (), \n              ng_f ,   tbx . loVect (),   tbx . hiVect (),   dx [ 0 ],   dt ); \n   }  }   The OpenMP parallelism is coarse-grained; rather than constructing a large Box  from  mfi.validbox() , it constructs a smaller  Box  from mfi.tilebox() . The metadata format remains unchanged, allowing the Fortran\nfunction to remain unchanged as well.", 
            "title": "Code Layout"
        }, 
        {
            "location": "/case_studies/amr/multigrid/", 
            "text": "Geometric Multigrid\n\n\nMany problems encountered in BoxLib applications require solutions to linear\nsystem, e.g., elliptic partial differential equations such as the Poisson\nequation for self-gravity, and the diffusion equation. BoxLib therefore\nincludes geometric multigrid solvers for solving problems which use both\ncell-centered and nodal data. For this project, we have focused on the\ncell-centered solver due to its relative simplicity compared to the nodal\nsolver.\n\n\nGeometric multigrid is an iterative method for solving linear problems which\ncontains roughly 4 steps:\n\n\n\n\nrelaxation\n\n\nrestriction\n\n\nprolongation\n\n\ncoarse-grid linear solve (either approximate or exact)\n\n\n\n\nAlthough here we will not discuss the details of the geometric multigrid\nmethod, we summarize each of these steps below as they pertain to computational\nalgorithms. Although these steps are algorithmically unique, we note that all\nof them feature low arithmetic intensity and are thus sensitive to cache and\nmemory bandwidth.\n\n\nRelaxation\n\n\nA relaxation consists of one or more iterations of an approximate solution to\nthe system of linear equations. In geometric multigrid, common algorithms used\nhere include Jacobi and Gauss-Seidel. By default, the BoxLib solver uses a\nvariation on Gauss-Seidel called Gauss-Seidel red-black (\"GSRB\"). GSRB deviates\nfrom the original Gauss-Seidel method by exploiting a symmetry in the data\ndependence among matrix elements, such that an update sweep of all matrix\nelements follows a stride-2 pattern rather than stride-1. (This property\nmanifests in the innermost loop of the kernel shown below).\n\n\ndo \nk\n \n=\n \nlo\n(\n3\n),\n \nhi\n(\n3\n)\n\n  \ndo \nj\n \n=\n \nlo\n(\n2\n),\n \nhi\n(\n2\n)\n\n     \nioff\n \n=\n \nMOD\n(\nlo\n(\n1\n)\n \n+\n \nj\n \n+\n \nk\n \n+\n \nredblack\n,\n2\n)\n\n     \ndo \ni\n \n=\n \nlo\n(\n1\n)\n \n+\n \nioff\n,\nhi\n(\n1\n),\n2\n\n        \ngamma\n \n=\n \nalpha\n*\na\n(\ni\n,\nj\n,\nk\n)\n \n\n              \n+\n   \ndhx\n*\n(\nbX\n(\ni\n,\nj\n,\nk\n)\n+\nbX\n(\ni\n+\n1\n,\nj\n,\nk\n))\n \n\n              \n+\n   \ndhy\n*\n(\nbY\n(\ni\n,\nj\n,\nk\n)\n+\nbY\n(\ni\n,\nj\n+\n1\n,\nk\n))\n \n\n              \n+\n   \ndhz\n*\n(\nbZ\n(\ni\n,\nj\n,\nk\n)\n+\nbZ\n(\ni\n,\nj\n,\nk\n+\n1\n))\n\n\n        \ng_m_d\n \n=\n \ngamma\n \n\n              \n-\n \n(\ndhx\n*\n(\nbX\n(\ni\n,\nj\n,\nk\n)\n*\ncf0\n \n+\n \nbX\n(\ni\n+\n1\n,\nj\n,\nk\n)\n*\ncf3\n)\n \n\n              \n+\n  \ndhy\n*\n(\nbY\n(\ni\n,\nj\n,\nk\n)\n*\ncf1\n \n+\n \nbY\n(\ni\n,\nj\n+\n1\n,\nk\n)\n*\ncf4\n)\n \n\n              \n+\n  \ndhz\n*\n(\nbZ\n(\ni\n,\nj\n,\nk\n)\n*\ncf2\n \n+\n \nbZ\n(\ni\n,\nj\n,\nk\n+\n1\n)\n*\ncf5\n))\n \n\n\n        \nrho\n \n=\n \ndhx\n*\n(\n \nbX\n(\ni\n  \n,\nj\n,\nk\n)\n*\nphi\n(\ni\n-\n1\n,\nj\n,\nk\n)\n \n\n            \n+\n       \nbX\n(\ni\n+\n1\n,\nj\n,\nk\n)\n*\nphi\n(\ni\n+\n1\n,\nj\n,\nk\n)\n \n)\n \n\n            \n+\n \ndhy\n*\n(\n \nbY\n(\ni\n,\nj\n  \n,\nk\n)\n*\nphi\n(\ni\n,\nj\n-\n1\n,\nk\n)\n \n\n            \n+\n       \nbY\n(\ni\n,\nj\n+\n1\n,\nk\n)\n*\nphi\n(\ni\n,\nj\n+\n1\n,\nk\n)\n \n)\n \n\n            \n+\n \ndhz\n*\n(\n \nbZ\n(\ni\n,\nj\n,\nk\n  \n)\n*\nphi\n(\ni\n,\nj\n,\nk\n-\n1\n)\n \n\n            \n+\n       \nbZ\n(\ni\n,\nj\n,\nk\n+\n1\n)\n*\nphi\n(\ni\n,\nj\n,\nk\n+\n1\n)\n \n)\n \n\n\n        \nres\n \n=\n  \nrhs\n(\ni\n,\nj\n,\nk\n)\n \n-\n \n(\ngamma\n*\nphi\n(\ni\n,\nj\n,\nk\n)\n \n-\n \nrho\n)\n\n        \nphi\n(\ni\n,\nj\n,\nk\n)\n \n=\n \nphi\n(\ni\n,\nj\n,\nk\n)\n \n+\n \nomega\n/\ng_m_d\n \n*\n \nres\n\n     \nend do\n\n\n  end do\n\n\nend do\n\n\n\n\n\nThe algorithm above uses a 7-point cell-centered discretization of the 3-D\nvariable-coefficient Helmholtz operator. The diffusion operator is one type of\nHelmholtz operator; the Laplace operator, which appears in the Poisson equation\nfor self-gravity, is a simplified version, with constant coefficients.\n\n\nThe GSRB method for a 7-point discretization of the Helmholtz operator exhibits\na low arithmetic intensity, requiring several non-contiguous loads from memory\nto evaluate the operator.\n\n\nThe relaxation step and the coarse grid solve (discussed belowed) often feature\nsimilar computational and data access patterns, because both are effectively\ndoing the same thing - solving a linear system. The primary difference between\nthem is that the relaxation method applies the iterative kernel only a handful\nof times, whereas the coarse grid solve often iterates all the way to\nconvergence.\n\n\nRestriction\n\n\nDuring a restriction, the value of a field on a fine grid is approximated on a\ncoarser grid. This is typically done by averaging values of the field on fine\ngrid points onto the corresponding grid points on the coarse grid. In BoxLib,\nthe algorithm is the following:\n\n\ndo \nk\n \n=\n \nlo\n(\n3\n),\n \nhi\n(\n3\n)\n\n  \nk2\n \n=\n \n2\n*\nk\n\n  \nk2p1\n \n=\n \nk2\n \n+\n \n1\n\n  \ndo \nj\n \n=\n \nlo\n(\n2\n),\n \nhi\n(\n2\n)\n\n    \nj2\n \n=\n \n2\n*\nj\n\n    \nj2p1\n \n=\n \nj2\n \n+\n \n1\n\n    \ndo \ni\n \n=\n \nlo\n(\n1\n),\n \nhi\n(\n1\n)\n\n      \ni2\n \n=\n \n2\n*\ni\n\n      \ni2p1\n \n=\n \ni2\n \n+\n \n1\n\n      \nc\n(\ni\n,\nj\n,\nk\n)\n \n=\n  \n(\n\n\n$\n                 \n+\n \nf\n(\ni2p1\n,\nj2p1\n,\nk2\n  \n)\n \n+\n \nf\n(\ni2\n,\nj2p1\n,\nk2\n  \n)\n\n\n$\n                 \n+\n \nf\n(\ni2p1\n,\nj2\n  \n,\nk2\n  \n)\n \n+\n \nf\n(\ni2\n,\nj2\n  \n,\nk2\n  \n)\n\n\n$\n                 \n+\n \nf\n(\ni2p1\n,\nj2p1\n,\nk2p1\n)\n \n+\n \nf\n(\ni2\n,\nj2p1\n,\nk2p1\n)\n\n\n$\n                 \n+\n \nf\n(\ni2p1\n,\nj2\n  \n,\nk2p1\n)\n \n+\n \nf\n(\ni2\n,\nj2\n  \n,\nk2p1\n)\n\n\n$\n                 \n)\n*\neighth\n\n    \nend do\n\n\n  end do\n\n\nend do\n\n\n\n\n\nwhere \nf\n is the field on the fine grid and \nc\n is the field on the coarse\ngrid. (This multigrid solver always coarsens grids by factors of two in each\ndimension.) For each evaluation of a coarse grid point, the algorithm must load\n8 values from the fine grid. However, there is significant memory locality in\nthis algorithm, as many of the fine grid points for coarse grid point\n\nc(i,j,k)\n also contribute to the point \nc(i+1,j,k)\n.\n\n\nProlongation\n\n\nProlongation (also called interpolation) is the opposite of restriction: one\napproximates the value of a field on a coarse grid on a finer grid. The\nprolongation kernel in the BoxLib solver is as follows:\n\ndo \nk\n \n=\n \nlo\n(\n3\n),\n \nhi\n(\n3\n)\n\n  \nk2\n \n=\n \n2\n*\nk\n\n  \nk2p1\n \n=\n \nk2\n \n+\n \n1\n\n  \ndo \nj\n \n=\n \nlo\n(\n2\n),\n \nhi\n(\n2\n)\n\n    \nj2\n \n=\n \n2\n*\nj\n\n    \nj2p1\n \n=\n \nj2\n \n+\n \n1\n\n    \ndo \ni\n \n=\n \nlo\n(\n1\n),\n \nhi\n(\n1\n)\n\n      \ni2\n \n=\n \n2\n*\ni\n\n      \ni2p1\n \n=\n \ni2\n \n+\n \n1\n\n\n      \nf\n(\ni2p1\n,\nj2p1\n,\nk2\n  \n)\n \n=\n \nc\n(\ni\n,\nj\n,\nk\n)\n \n+\n \nf\n(\ni2p1\n,\nj2p1\n,\nk2\n  \n)\n\n      \nf\n(\ni2\n  \n,\nj2p1\n,\nk2\n  \n)\n \n=\n \nc\n(\ni\n,\nj\n,\nk\n)\n \n+\n \nf\n(\ni2\n  \n,\nj2p1\n,\nk2\n  \n)\n\n      \nf\n(\ni2p1\n,\nj2\n  \n,\nk2\n  \n)\n \n=\n \nc\n(\ni\n,\nj\n,\nk\n)\n \n+\n \nf\n(\ni2p1\n,\nj2\n  \n,\nk2\n  \n)\n\n      \nf\n(\ni2\n  \n,\nj2\n  \n,\nk2\n  \n)\n \n=\n \nc\n(\ni\n,\nj\n,\nk\n)\n \n+\n \nf\n(\ni2\n  \n,\nj2\n  \n,\nk2\n  \n)\n\n      \nf\n(\ni2p1\n,\nj2p1\n,\nk2p1\n)\n \n=\n \nc\n(\ni\n,\nj\n,\nk\n)\n \n+\n \nf\n(\ni2p1\n,\nj2p1\n,\nk2p1\n)\n\n      \nf\n(\ni2\n  \n,\nj2p1\n,\nk2p1\n)\n \n=\n \nc\n(\ni\n,\nj\n,\nk\n)\n \n+\n \nf\n(\ni2\n  \n,\nj2p1\n,\nk2p1\n)\n\n      \nf\n(\ni2p1\n,\nj2\n  \n,\nk2p1\n)\n \n=\n \nc\n(\ni\n,\nj\n,\nk\n)\n \n+\n \nf\n(\ni2p1\n,\nj2\n  \n,\nk2p1\n)\n\n      \nf\n(\ni2\n  \n,\nj2\n  \n,\nk2p1\n)\n \n=\n \nc\n(\ni\n,\nj\n,\nk\n)\n \n+\n \nf\n(\ni2\n  \n,\nj2\n  \n,\nk2p1\n)\n\n\n    \nend do\n\n\n  end do\n\n\nend do\n\n\n\n\nIn 3-D, the same value on the coarse grid contributes equally to eight\nneighboring points in the fine grid. (The symmetry arises from the constraint\nin the solver that the cells must be cubic.)\n\n\nExact linear solve\n\n\nThe multigrid solver in BoxLib recursively coarsens grids until the grid\nreaches a sufficiently small size, often \n\\(2^3\\)\n if the problem domain is cubic.\nOn the coarsest grid, the solver then solves the linear system exactly, before\npropagating the solution back up to finer grids. The solution algorithm chosen\nfor this step is rarely influential on the overall performance of the multigrid\nalgorithm, because the problem size at the coarsest grid is so small. In\nBoxLib, the default coarse grid solver algorithm is BiCGSTAB, a variation on\nthe conjugate-gradient iterative method.", 
            "title": "Geometric Multigrid"
        }, 
        {
            "location": "/case_studies/amr/multigrid/#geometric-multigrid", 
            "text": "Many problems encountered in BoxLib applications require solutions to linear\nsystem, e.g., elliptic partial differential equations such as the Poisson\nequation for self-gravity, and the diffusion equation. BoxLib therefore\nincludes geometric multigrid solvers for solving problems which use both\ncell-centered and nodal data. For this project, we have focused on the\ncell-centered solver due to its relative simplicity compared to the nodal\nsolver.  Geometric multigrid is an iterative method for solving linear problems which\ncontains roughly 4 steps:   relaxation  restriction  prolongation  coarse-grid linear solve (either approximate or exact)   Although here we will not discuss the details of the geometric multigrid\nmethod, we summarize each of these steps below as they pertain to computational\nalgorithms. Although these steps are algorithmically unique, we note that all\nof them feature low arithmetic intensity and are thus sensitive to cache and\nmemory bandwidth.", 
            "title": "Geometric Multigrid"
        }, 
        {
            "location": "/case_studies/amr/multigrid/#relaxation", 
            "text": "A relaxation consists of one or more iterations of an approximate solution to\nthe system of linear equations. In geometric multigrid, common algorithms used\nhere include Jacobi and Gauss-Seidel. By default, the BoxLib solver uses a\nvariation on Gauss-Seidel called Gauss-Seidel red-black (\"GSRB\"). GSRB deviates\nfrom the original Gauss-Seidel method by exploiting a symmetry in the data\ndependence among matrix elements, such that an update sweep of all matrix\nelements follows a stride-2 pattern rather than stride-1. (This property\nmanifests in the innermost loop of the kernel shown below).  do  k   =   lo ( 3 ),   hi ( 3 ) \n   do  j   =   lo ( 2 ),   hi ( 2 ) \n      ioff   =   MOD ( lo ( 1 )   +   j   +   k   +   redblack , 2 ) \n      do  i   =   lo ( 1 )   +   ioff , hi ( 1 ), 2 \n         gamma   =   alpha * a ( i , j , k )   \n               +     dhx * ( bX ( i , j , k ) + bX ( i + 1 , j , k ))   \n               +     dhy * ( bY ( i , j , k ) + bY ( i , j + 1 , k ))   \n               +     dhz * ( bZ ( i , j , k ) + bZ ( i , j , k + 1 )) \n\n         g_m_d   =   gamma   \n               -   ( dhx * ( bX ( i , j , k ) * cf0   +   bX ( i + 1 , j , k ) * cf3 )   \n               +    dhy * ( bY ( i , j , k ) * cf1   +   bY ( i , j + 1 , k ) * cf4 )   \n               +    dhz * ( bZ ( i , j , k ) * cf2   +   bZ ( i , j , k + 1 ) * cf5 ))   \n\n         rho   =   dhx * (   bX ( i    , j , k ) * phi ( i - 1 , j , k )   \n             +         bX ( i + 1 , j , k ) * phi ( i + 1 , j , k )   )   \n             +   dhy * (   bY ( i , j    , k ) * phi ( i , j - 1 , k )   \n             +         bY ( i , j + 1 , k ) * phi ( i , j + 1 , k )   )   \n             +   dhz * (   bZ ( i , j , k    ) * phi ( i , j , k - 1 )   \n             +         bZ ( i , j , k + 1 ) * phi ( i , j , k + 1 )   )   \n\n         res   =    rhs ( i , j , k )   -   ( gamma * phi ( i , j , k )   -   rho ) \n         phi ( i , j , k )   =   phi ( i , j , k )   +   omega / g_m_d   *   res \n      end do    end do  end do   The algorithm above uses a 7-point cell-centered discretization of the 3-D\nvariable-coefficient Helmholtz operator. The diffusion operator is one type of\nHelmholtz operator; the Laplace operator, which appears in the Poisson equation\nfor self-gravity, is a simplified version, with constant coefficients.  The GSRB method for a 7-point discretization of the Helmholtz operator exhibits\na low arithmetic intensity, requiring several non-contiguous loads from memory\nto evaluate the operator.  The relaxation step and the coarse grid solve (discussed belowed) often feature\nsimilar computational and data access patterns, because both are effectively\ndoing the same thing - solving a linear system. The primary difference between\nthem is that the relaxation method applies the iterative kernel only a handful\nof times, whereas the coarse grid solve often iterates all the way to\nconvergence.", 
            "title": "Relaxation"
        }, 
        {
            "location": "/case_studies/amr/multigrid/#restriction", 
            "text": "During a restriction, the value of a field on a fine grid is approximated on a\ncoarser grid. This is typically done by averaging values of the field on fine\ngrid points onto the corresponding grid points on the coarse grid. In BoxLib,\nthe algorithm is the following:  do  k   =   lo ( 3 ),   hi ( 3 ) \n   k2   =   2 * k \n   k2p1   =   k2   +   1 \n   do  j   =   lo ( 2 ),   hi ( 2 ) \n     j2   =   2 * j \n     j2p1   =   j2   +   1 \n     do  i   =   lo ( 1 ),   hi ( 1 ) \n       i2   =   2 * i \n       i2p1   =   i2   +   1 \n       c ( i , j , k )   =    (  $                   +   f ( i2p1 , j2p1 , k2    )   +   f ( i2 , j2p1 , k2    )  $                   +   f ( i2p1 , j2    , k2    )   +   f ( i2 , j2    , k2    )  $                   +   f ( i2p1 , j2p1 , k2p1 )   +   f ( i2 , j2p1 , k2p1 )  $                   +   f ( i2p1 , j2    , k2p1 )   +   f ( i2 , j2    , k2p1 )  $                   ) * eighth \n     end do    end do  end do   where  f  is the field on the fine grid and  c  is the field on the coarse\ngrid. (This multigrid solver always coarsens grids by factors of two in each\ndimension.) For each evaluation of a coarse grid point, the algorithm must load\n8 values from the fine grid. However, there is significant memory locality in\nthis algorithm, as many of the fine grid points for coarse grid point c(i,j,k)  also contribute to the point  c(i+1,j,k) .", 
            "title": "Restriction"
        }, 
        {
            "location": "/case_studies/amr/multigrid/#prolongation", 
            "text": "Prolongation (also called interpolation) is the opposite of restriction: one\napproximates the value of a field on a coarse grid on a finer grid. The\nprolongation kernel in the BoxLib solver is as follows: do  k   =   lo ( 3 ),   hi ( 3 ) \n   k2   =   2 * k \n   k2p1   =   k2   +   1 \n   do  j   =   lo ( 2 ),   hi ( 2 ) \n     j2   =   2 * j \n     j2p1   =   j2   +   1 \n     do  i   =   lo ( 1 ),   hi ( 1 ) \n       i2   =   2 * i \n       i2p1   =   i2   +   1 \n\n       f ( i2p1 , j2p1 , k2    )   =   c ( i , j , k )   +   f ( i2p1 , j2p1 , k2    ) \n       f ( i2    , j2p1 , k2    )   =   c ( i , j , k )   +   f ( i2    , j2p1 , k2    ) \n       f ( i2p1 , j2    , k2    )   =   c ( i , j , k )   +   f ( i2p1 , j2    , k2    ) \n       f ( i2    , j2    , k2    )   =   c ( i , j , k )   +   f ( i2    , j2    , k2    ) \n       f ( i2p1 , j2p1 , k2p1 )   =   c ( i , j , k )   +   f ( i2p1 , j2p1 , k2p1 ) \n       f ( i2    , j2p1 , k2p1 )   =   c ( i , j , k )   +   f ( i2    , j2p1 , k2p1 ) \n       f ( i2p1 , j2    , k2p1 )   =   c ( i , j , k )   +   f ( i2p1 , j2    , k2p1 ) \n       f ( i2    , j2    , k2p1 )   =   c ( i , j , k )   +   f ( i2    , j2    , k2p1 ) \n\n     end do    end do  end do   In 3-D, the same value on the coarse grid contributes equally to eight\nneighboring points in the fine grid. (The symmetry arises from the constraint\nin the solver that the cells must be cubic.)", 
            "title": "Prolongation"
        }, 
        {
            "location": "/case_studies/amr/multigrid/#exact-linear-solve", 
            "text": "The multigrid solver in BoxLib recursively coarsens grids until the grid\nreaches a sufficiently small size, often  \\(2^3\\)  if the problem domain is cubic.\nOn the coarsest grid, the solver then solves the linear system exactly, before\npropagating the solution back up to finer grids. The solution algorithm chosen\nfor this step is rarely influential on the overall performance of the multigrid\nalgorithm, because the problem size at the coarsest grid is so small. In\nBoxLib, the default coarse grid solver algorithm is BiCGSTAB, a variation on\nthe conjugate-gradient iterative method.", 
            "title": "Exact linear solve"
        }, 
        {
            "location": "/case_studies/gw/", 
            "text": "", 
            "title": "GW Kernels"
        }, 
        {
            "location": "/case_studies/qcd/overview/", 
            "text": "Introduction to Lattice QCD\n\n\nLattice QCD\n is a numerical method to evaluate \nQuantum Chromodynamics (QCD)\n,\nthe theory of the strong interaction which binds quarks into nucleons and nucleons into nuclei,\nin a straightforward way with quantifiable uncertainties. It is non-perturbative and thus has access\nto energy regimes where common analytical methods fail.\nIn orer to transform continuum QCD to Lattice QCD, one first rotates the time axis to imaginary times which \ntransforms the 4-dimensional \nMinkowski space\n into Eculidian \n\\(\\mathbb{R}^4\\)\n. Then,\neuclidian space-time is discretized by introducing a lattice spacing \n\\(a\\)\n as well as finite volume with side extents \n\\(L\\)\n.\n\n\nWilson Fermions\n\n\nThe most expensive part of Lattice QCD is the calculation of so-called quark propagators, i.e.\ncomputing the solution of the Dirac equation\n\n\\((m - /\\!\\!\\!\\!D)\\psi = \\eta\\)\n, where \n\\(m\\)\n is the mass of the particle, \n\\(\\eta\\)\n is a given vector (we will refer to this object as \nsource\n or \nright-hand-side spinor\n)\nand \n\\(/\\!\\!\\!\\!D\\)\n is a so-called gauge-covariant, Fermion derivative operator. There are many possibilities for discretizing the\ncontinuum version of the Fermion derivative operator and the most common one are the so-called \nWilson fermions\n. In this discretizaton,\nthe operator, also called Wilson operator, is given by\n\n\n\\[\n/\\!\\!\\!\\!D(x,y) = \\sum\\limits_{\\mu=0}^3 U_{\\mu}(x)(1-\\gamma_{\\mu})\\delta_{y,x+\\hat{\\mu}}+U^{\\dagger}_{\\mu}(x-\\hat{\\mu})(1+\\gamma_{\\mu})\\delta_{y,x-\\hat{\\mu}}.\n\\]\nHere, \n\\(\\hat{\\mu}\\)\n denotes a displacement in \n\\(\\mu\\)\n-direction by one lattice site. \n\\(U_{\\mu}(x)\\)\n are the so-called links connecting the neighboring sites \n\\(x\\)\n and \n\\(x+\\hat{\\mu}\\)\n in a gauge-covariant way. They are elements of \n\\(SU(3)\\)\n, i.e. they can be described by 3x3 complex-valued, \nunitary matrices\n with unit \ndeterminant\n. The \n\\(\\gamma_{\\mu}\\)\n are sparse 4x4 matrices and are the generators of the so-called \nDirac algebra\n, a 4-dimensional spin \nClifford algebra\n. The indices of \n\\(U\\)\n and \n\\(\\gamma\\)\n are called color and spin indices respectively. \nNote that the Wilson operator couples only neighboring lattice sites and is thus ultra-local.\n\n\nIn modern lattice calculations, the majority of CPU time is spent on solving the Dirac equation. Therefore,\nmost optimization efforts focus on optimizing the Wilson operator as well as solvers which use this operator as their kernel.\nIt is thus importanto to find out whether the Wilson operator can be implemented in a performance portable way.\n\n\nImplementation\n\n\nIn this section we will briefly discuss architecture-independent implementation details of the Wilson operator. \n\n\nMultiple Right Hand Sides\n\n\nAn efficient way to increase the arithmetic intensity in sparse linear systems is to solve for multiple right hand side vectors simulatenously.\nThis case is also relevant to many lattice QCD applications so that we have implemented this optimization in our small test case. \n\n\nArithmetic Intensity\n\n\nThe arithmetic intensity for the Wilson operator can be computed as follows:\n\n\n\\[\n\\frac{\\#\\mathrm{Flops}}{\\#\\mathrm{Bytes}} = \\frac{1320}{8G + (9-R+r)S},\n\\]\nwhere \n\\(G\\)\n is the size of a gauge link, \n\\(S\\)\n the size of a spinor, \n\\(R\\)\n the nearest neighbor spinor reuse factor and \n\\(r=0\\)\n if streaming stores are used and \n\\(r=1\\)\n otherwise (read-for-write). The constant factors account for the fact that in 4 dimensions, each lattice site has 8 neighbors and thus 8 links and spinors needs to be read from memory and one spinor needs to be written. If no streaming stores are used, the output spinor needs to be read into cache first and thus the total number of spinors transferred per computed site will be 10 in this case. Whereas the spinor always consists of 12 complex numbers (3 color and 4 spin components), the gauge links G can be in theory compressed to 8 real numbers by using properties of \nLie algebras\n along with the generators of \n\\(SU(3)\\)\n. However, this is very expensive so that usually a less aggressive form of compression is used by simply dropping one row or column of the gauge link and reconstruct it on the fly when needed. This format is called \n12-compression\n and widely used in modern Wilson operator implementations. In our simple test case however, we do not use this kind of compression and thus the expected arithmetic intensity is between \n\\(0.86\\)\n \n\\((R=0,\\,r=1,\\,G=18)\\)\n and \n\\(1.72\\)\n \n\\((R=7,\\,r=0,\\,G=18)\\)\n for single precision.\n\n\nWe have applied two optimizations to our Wilson dslash test code\n\n\n\n\nwe replace the Wilson operator with it's \nSchur complement\n, i.e. we use \n\\(M_{oo} = m - /\\!\\!\\!\\!D_{oe} m^{-1} /\\!\\!\\!\\!D_{eo}\\)\n instead of applying \n\\(/\\!\\!\\!\\!D\\)\n directly. Here, the indices \n\\(oo\\)\n, \n\\(oe\\)\n and \n\\(eo\\)\n indicate that the respective operators only couple odd-odd, odd-even or even-odd sites respectively. With this optimization, the modified problem can essentially be solved on a volume half as big as the original problem and the solution easily be reconstructed for the other half.\n\n\nwe use properties of the Dirac matrices to project the 4-spinors to two pairs of linear dependent 2-spinors before applying the dslash, saving 50% of the required flops.\n\n\nwe solve for multiple right hand side vectors simultaneously to increase the arithmetic intensity. This optimizations amounts to multiplying the number of flops as well as the number of reads and stores by the number of right hand sides \n\\(N\\)\n. Since all these vectors should ideally be kept in cache, the effective reuse factor \n\\(R\\)\n will drop with increasing \n\\(N\\)\n. In our testcase we vectorize using SIMD or SIMT over these right hand side vectors, so \n\\(N\\)\n should ideally be an integer multiple of the vector/warp size. These two aspects have to be taken into account when optimizing the performance.", 
            "title": "Overview"
        }, 
        {
            "location": "/case_studies/qcd/overview/#introduction-to-lattice-qcd", 
            "text": "Lattice QCD  is a numerical method to evaluate  Quantum Chromodynamics (QCD) ,\nthe theory of the strong interaction which binds quarks into nucleons and nucleons into nuclei,\nin a straightforward way with quantifiable uncertainties. It is non-perturbative and thus has access\nto energy regimes where common analytical methods fail.\nIn orer to transform continuum QCD to Lattice QCD, one first rotates the time axis to imaginary times which \ntransforms the 4-dimensional  Minkowski space  into Eculidian  \\(\\mathbb{R}^4\\) . Then,\neuclidian space-time is discretized by introducing a lattice spacing  \\(a\\)  as well as finite volume with side extents  \\(L\\) .", 
            "title": "Introduction to Lattice QCD"
        }, 
        {
            "location": "/case_studies/qcd/overview/#wilson-fermions", 
            "text": "The most expensive part of Lattice QCD is the calculation of so-called quark propagators, i.e.\ncomputing the solution of the Dirac equation \\((m - /\\!\\!\\!\\!D)\\psi = \\eta\\) , where  \\(m\\)  is the mass of the particle,  \\(\\eta\\)  is a given vector (we will refer to this object as  source  or  right-hand-side spinor )\nand  \\(/\\!\\!\\!\\!D\\)  is a so-called gauge-covariant, Fermion derivative operator. There are many possibilities for discretizing the\ncontinuum version of the Fermion derivative operator and the most common one are the so-called  Wilson fermions . In this discretizaton,\nthe operator, also called Wilson operator, is given by  \\[\n/\\!\\!\\!\\!D(x,y) = \\sum\\limits_{\\mu=0}^3 U_{\\mu}(x)(1-\\gamma_{\\mu})\\delta_{y,x+\\hat{\\mu}}+U^{\\dagger}_{\\mu}(x-\\hat{\\mu})(1+\\gamma_{\\mu})\\delta_{y,x-\\hat{\\mu}}.\n\\] Here,  \\(\\hat{\\mu}\\)  denotes a displacement in  \\(\\mu\\) -direction by one lattice site.  \\(U_{\\mu}(x)\\)  are the so-called links connecting the neighboring sites  \\(x\\)  and  \\(x+\\hat{\\mu}\\)  in a gauge-covariant way. They are elements of  \\(SU(3)\\) , i.e. they can be described by 3x3 complex-valued,  unitary matrices  with unit  determinant . The  \\(\\gamma_{\\mu}\\)  are sparse 4x4 matrices and are the generators of the so-called  Dirac algebra , a 4-dimensional spin  Clifford algebra . The indices of  \\(U\\)  and  \\(\\gamma\\)  are called color and spin indices respectively. \nNote that the Wilson operator couples only neighboring lattice sites and is thus ultra-local.  In modern lattice calculations, the majority of CPU time is spent on solving the Dirac equation. Therefore,\nmost optimization efforts focus on optimizing the Wilson operator as well as solvers which use this operator as their kernel.\nIt is thus importanto to find out whether the Wilson operator can be implemented in a performance portable way.", 
            "title": "Wilson Fermions"
        }, 
        {
            "location": "/case_studies/qcd/overview/#implementation", 
            "text": "In this section we will briefly discuss architecture-independent implementation details of the Wilson operator.", 
            "title": "Implementation"
        }, 
        {
            "location": "/case_studies/qcd/overview/#multiple-right-hand-sides", 
            "text": "An efficient way to increase the arithmetic intensity in sparse linear systems is to solve for multiple right hand side vectors simulatenously.\nThis case is also relevant to many lattice QCD applications so that we have implemented this optimization in our small test case.", 
            "title": "Multiple Right Hand Sides"
        }, 
        {
            "location": "/case_studies/qcd/overview/#arithmetic-intensity", 
            "text": "The arithmetic intensity for the Wilson operator can be computed as follows:  \\[\n\\frac{\\#\\mathrm{Flops}}{\\#\\mathrm{Bytes}} = \\frac{1320}{8G + (9-R+r)S},\n\\] where  \\(G\\)  is the size of a gauge link,  \\(S\\)  the size of a spinor,  \\(R\\)  the nearest neighbor spinor reuse factor and  \\(r=0\\)  if streaming stores are used and  \\(r=1\\)  otherwise (read-for-write). The constant factors account for the fact that in 4 dimensions, each lattice site has 8 neighbors and thus 8 links and spinors needs to be read from memory and one spinor needs to be written. If no streaming stores are used, the output spinor needs to be read into cache first and thus the total number of spinors transferred per computed site will be 10 in this case. Whereas the spinor always consists of 12 complex numbers (3 color and 4 spin components), the gauge links G can be in theory compressed to 8 real numbers by using properties of  Lie algebras  along with the generators of  \\(SU(3)\\) . However, this is very expensive so that usually a less aggressive form of compression is used by simply dropping one row or column of the gauge link and reconstruct it on the fly when needed. This format is called  12-compression  and widely used in modern Wilson operator implementations. In our simple test case however, we do not use this kind of compression and thus the expected arithmetic intensity is between  \\(0.86\\)   \\((R=0,\\,r=1,\\,G=18)\\)  and  \\(1.72\\)   \\((R=7,\\,r=0,\\,G=18)\\)  for single precision.  We have applied two optimizations to our Wilson dslash test code   we replace the Wilson operator with it's  Schur complement , i.e. we use  \\(M_{oo} = m - /\\!\\!\\!\\!D_{oe} m^{-1} /\\!\\!\\!\\!D_{eo}\\)  instead of applying  \\(/\\!\\!\\!\\!D\\)  directly. Here, the indices  \\(oo\\) ,  \\(oe\\)  and  \\(eo\\)  indicate that the respective operators only couple odd-odd, odd-even or even-odd sites respectively. With this optimization, the modified problem can essentially be solved on a volume half as big as the original problem and the solution easily be reconstructed for the other half.  we use properties of the Dirac matrices to project the 4-spinors to two pairs of linear dependent 2-spinors before applying the dslash, saving 50% of the required flops.  we solve for multiple right hand side vectors simultaneously to increase the arithmetic intensity. This optimizations amounts to multiplying the number of flops as well as the number of reads and stores by the number of right hand sides  \\(N\\) . Since all these vectors should ideally be kept in cache, the effective reuse factor  \\(R\\)  will drop with increasing  \\(N\\) . In our testcase we vectorize using SIMD or SIMT over these right hand side vectors, so  \\(N\\)  should ideally be an integer multiple of the vector/warp size. These two aspects have to be taken into account when optimizing the performance.", 
            "title": "Arithmetic Intensity"
        }, 
        {
            "location": "/case_studies/qcd/code_structure/", 
            "text": "Code Structure\n\n\nOur testcode is written in C++ and designed completely from scratch. We use type definitions, templates, template-specialization, overloading and other C++ features to provide flexibility in changing precision, testing datatypes which help vectorization and also making it easier to hide architecture dependent code. The general idea is to decompose the problem into a loop over lattice site and then for each lattice site and each direction, we:\n\n\n\n\nstream-in the relevant spinors (or block of spinors in case of multiple right hand sides) from memory\n\n\nproject 4-spinors to 2-spinors\n\n\nread relevant gauge links and apply the dslash to those vectors\n\n\ninject 2-spinors into 4-spinors\n\n\nstream-out the solution vectors to memory\n\n\n\n\nIn multi-node implementations the application step would be separated into bulk- and boundary application and the former interleaved with boundary communication.\n\n\nData Primitives\n\n\nFor facilitating this workflow, we define spinor and gauge link classes (in C++-like pseudocode):\n\n\ntemplate\ntypename\n \nST\n,\nint\n \nnspin\n \n\nclass\n \nCBSpinor\n \n{\n\n\npublic\n:\n \n    \n...\n\n\nprivate\n:\n\n    \n// dims are: site, color, spin\n\n    \nspin_container\nST\n[\nsite\n,\ncolor\n,\nspin\n]\n \ndata\n;\n\n\n};\n\n\n\ntemplate\ntypename\n \nGT\n \n\nclass\n \nCBGaugeField\n \n{\n\n\npublic\n:\n\n    \n...\n\n\nprivate\n:\n\n    \n// dims are: site, direction, color, color\n\n    \ngauge_container\nGT\n[\nsite\n,\n4\n,\n3\n,\n3\n]\n \ndata\n;\n\n\n};\n\n\n\n\n\nhere, ST and GT refer to spinor-type and gauge-type respectively. Those types could be SIMD or scalar types and they do not neccesarily need to be the same. The data containers can be plain arrays, e.g. for (unportable) plain implementations, or arrays decorated with pragmas (e.g. for OpenMP 4.5 offloading) or more general data container classes such as Kokkos::Views, etc.. The member functions are adopted to the container classes used in the individual implementations. Note that this design allows us to test different performance portable frameworks/methods without having to restructure large parts of the code. The additional template paramter \nnspin\n allows us to easily define 2- and 4-spinor objects. \n\n\nWilson Operator\n\n\nAt this point in time, the dslash testcode is not multi-node ready, so we will focus solely on on-node parallelism for the moment. Our goal is to achieve this by threading over lattice sites and applying SIMD/SIMT parallelism over multiple right hand sides. In theory, one could achieve vectorization for single right hand side vectors also by using an array or structure of array data layout but we will not consider this technique here. We will nevertheless compare our single right hand side performance we achieved with our performance portable implementations with those of optimized libraries which feature such improvements.\n\n\nOur dslash class is implemented as follow:\n\n\ntemplate\ntypename\n \nGT\n,\n \ntypename\n \nST\n,\n \ntypename\n \nTST\n\n\nclass\n \nDslash\n \n{\n\n    \npublic\n:\n\n    \nvoid\n \noperator\n(\nconst\n \nCBSpinor\nST\n,\n4\n \ns_in\n,\n\n                  \nconst\n \nCBGaugeField\nGT\n \ng_in\n,\n\n                  \nCBSpinor\nST\n,\n4\n \ns_out\n,\n\n                  \nint\n \nplus_minus\n)\n \n    \n{\n\n        \n// Threaded loop over sites\n\n        \nparallel_for\n(\nint\n \ni\n=\n0\n;\n \ni\nnum_sites\n;\n \ni\n++\n){\n\n            \nCBThreadSpinor\nTST\n,\n4\n \nres_sum_\n;\n\n            \nCBThreadSpinor\nTST\n,\n2\n \nproj_res\n,\n \nmult_proj_res\n;\n\n\n            \n//go for directions +T\n\n            \n//stream-in from +T direction and project to 2-spinor\n\n            \nproject_dir\nST\n,\nTST\n(\ns_in\n[\ni\n],\n \ni\n,\n \nproj_res\n,\n \nT_PLUS\n);\n\n            \n//multiply with gauge link\n\n            \nmult_adj_u_halfspinor\nGT\n,\nTST\n(\ng_in\n[\ni\n][\nT_PLUS\n],\n \nproj_res\n,\n \nmult_proj_res\n);\n\n            \n//reconstruct and add to result\n\n            \nreconstruct_dir\nTST\n,\nST\n(\nmult_proj_res\n,\n \nres_sum\n);\n\n\n            \n//go for direction -T\n\n            \n...\n\n        \n}\n\n    \n}\n\n\n};\n\n\n\n\n\nHere, the type \nTST\n denotes a thread-spinor-type which belongs to the \nCBThreadSpinor\n class. It is important to make the distinction between \nCBSpinor\n and \nCBThreadSpinor\n because, depending on the performance portability framework used, this type has to be different on CPU or GPU. What we would like to achieve ultimately is displayed in the picture below:\n\n\n\n\nIn case of the GPU (left), individual threads are each working on a single/scalar entry of the global spinor, i.e. on a single right hand side component. In case of the CPU (right), each thread is working on a chunk of right hand sites, ideally using its vector units. In both cases, the input and output spinor datatype is the same and the work spinor type is optimized for the targeted architecture. \n\n\nNote that, similar to the data classes discussed above, this skeleton-dslash allows us to specialize the Wilson operator for a variety of performance portable frameworks. Additionally, if we need more architectural specialization than the various frameworks could offer, this can be implemented cleanly by operator overloading and template specializations.", 
            "title": "Code Structure"
        }, 
        {
            "location": "/case_studies/qcd/code_structure/#code-structure", 
            "text": "Our testcode is written in C++ and designed completely from scratch. We use type definitions, templates, template-specialization, overloading and other C++ features to provide flexibility in changing precision, testing datatypes which help vectorization and also making it easier to hide architecture dependent code. The general idea is to decompose the problem into a loop over lattice site and then for each lattice site and each direction, we:   stream-in the relevant spinors (or block of spinors in case of multiple right hand sides) from memory  project 4-spinors to 2-spinors  read relevant gauge links and apply the dslash to those vectors  inject 2-spinors into 4-spinors  stream-out the solution vectors to memory   In multi-node implementations the application step would be separated into bulk- and boundary application and the former interleaved with boundary communication.", 
            "title": "Code Structure"
        }, 
        {
            "location": "/case_studies/qcd/code_structure/#data-primitives", 
            "text": "For facilitating this workflow, we define spinor and gauge link classes (in C++-like pseudocode):  template typename   ST , int   nspin   class   CBSpinor   {  public :  \n     ...  private : \n     // dims are: site, color, spin \n     spin_container ST [ site , color , spin ]   data ;  };  template typename   GT   class   CBGaugeField   {  public : \n     ...  private : \n     // dims are: site, direction, color, color \n     gauge_container GT [ site , 4 , 3 , 3 ]   data ;  };   here, ST and GT refer to spinor-type and gauge-type respectively. Those types could be SIMD or scalar types and they do not neccesarily need to be the same. The data containers can be plain arrays, e.g. for (unportable) plain implementations, or arrays decorated with pragmas (e.g. for OpenMP 4.5 offloading) or more general data container classes such as Kokkos::Views, etc.. The member functions are adopted to the container classes used in the individual implementations. Note that this design allows us to test different performance portable frameworks/methods without having to restructure large parts of the code. The additional template paramter  nspin  allows us to easily define 2- and 4-spinor objects.", 
            "title": "Data Primitives"
        }, 
        {
            "location": "/case_studies/qcd/code_structure/#wilson-operator", 
            "text": "At this point in time, the dslash testcode is not multi-node ready, so we will focus solely on on-node parallelism for the moment. Our goal is to achieve this by threading over lattice sites and applying SIMD/SIMT parallelism over multiple right hand sides. In theory, one could achieve vectorization for single right hand side vectors also by using an array or structure of array data layout but we will not consider this technique here. We will nevertheless compare our single right hand side performance we achieved with our performance portable implementations with those of optimized libraries which feature such improvements.  Our dslash class is implemented as follow:  template typename   GT ,   typename   ST ,   typename   TST  class   Dslash   { \n     public : \n     void   operator ( const   CBSpinor ST , 4   s_in , \n                   const   CBGaugeField GT   g_in , \n                   CBSpinor ST , 4   s_out , \n                   int   plus_minus )  \n     { \n         // Threaded loop over sites \n         parallel_for ( int   i = 0 ;   i num_sites ;   i ++ ){ \n             CBThreadSpinor TST , 4   res_sum_ ; \n             CBThreadSpinor TST , 2   proj_res ,   mult_proj_res ; \n\n             //go for directions +T \n             //stream-in from +T direction and project to 2-spinor \n             project_dir ST , TST ( s_in [ i ],   i ,   proj_res ,   T_PLUS ); \n             //multiply with gauge link \n             mult_adj_u_halfspinor GT , TST ( g_in [ i ][ T_PLUS ],   proj_res ,   mult_proj_res ); \n             //reconstruct and add to result \n             reconstruct_dir TST , ST ( mult_proj_res ,   res_sum ); \n\n             //go for direction -T \n             ... \n         } \n     }  };   Here, the type  TST  denotes a thread-spinor-type which belongs to the  CBThreadSpinor  class. It is important to make the distinction between  CBSpinor  and  CBThreadSpinor  because, depending on the performance portability framework used, this type has to be different on CPU or GPU. What we would like to achieve ultimately is displayed in the picture below:   In case of the GPU (left), individual threads are each working on a single/scalar entry of the global spinor, i.e. on a single right hand side component. In case of the CPU (right), each thread is working on a chunk of right hand sites, ideally using its vector units. In both cases, the input and output spinor datatype is the same and the work spinor type is optimized for the targeted architecture.   Note that, similar to the data classes discussed above, this skeleton-dslash allows us to specialize the Wilson operator for a variety of performance portable frameworks. Additionally, if we need more architectural specialization than the various frameworks could offer, this can be implemented cleanly by operator overloading and template specializations.", 
            "title": "Wilson Operator"
        }, 
        {
            "location": "/case_studies/qcd/kokkos_implementation/", 
            "text": "Kokkos Implementation\n\n\nIn this implementation, we will use the \nKokkos::View\n type as our data container. Therefore, the \nspinor and gaugefield classes\n become\n\n\ntemplate\ntypename\n \nST\n,\nint\n \nnspin\n \n\nclass\n \nCBSpinor\n \n{\n\n\npublic\n:\n \n    \n...\n\n\nprivate\n:\n\n    \n// dims are: site, color, spin\n\n    \nKokkos\n::\nView\nST\n*\n[\n3\n][\nnspin\n]\n \ndata\n;\n\n\n};\n\n\n\ntemplate\ntypename\n \nGT\n \n\nclass\n \nCBGaugeField\n \n{\n\n\npublic\n:\n\n    \n...\n\n\nprivate\n:\n\n    \n// dims are: site, direction, color, color\n\n    \ngauge_container\nGT\n*\n[\n4\n][\n3\n][\n3\n]\n \ndata\n;\n\n\n};\n\n\n\n\n\nNote that the site index dimension is a runtime dimension (denoted by \n*\n) whereas the other dimensions - color and spin - are fixed (denoted by \n[const]\n). Explicitly stating this is recommended by the kokkos developers because it should help the compiler to optimize the code. \n\n\nIn the \nWilsion operator class\n, all what we need to do is to insert the kokkos parallel dispatcher. Hence it becomes\n\n\ntemplate\ntypename\n \nGT\n,\n \ntypename\n \nST\n,\n \ntypename\n \nTST\n\n\nclass\n \nDslash\n \n{\n\n    \npublic\n:\n\n    \nvoid\n \noperator\n(\nconst\n \nCBSpinor\nST\n,\n4\n \ns_in\n,\n\n                  \nconst\n \nCBGaugeField\nGT\n \ng_in\n,\n\n                  \nCBSpinor\nST\n,\n4\n \ns_out\n,\n\n                  \nint\n \nplus_minus\n)\n \n    \n{\n\n        \n// Threaded loop over sites\n\n        \nKokkos\n::\nparallel_for\n(\nnum_sites\n,\n \nKOKKOS_LAMBDA\n(\nint\n \ni\n)\n \n{\n\n            \n...\n\n            \n});\n\n    \n}\n\n\n};\n\n\n\n\n\nEnsuring Vectorization\n\n\nVectorization in Kokkos is achieved by a two-level \nnested parallelism\n, where the outer loop spawns threads (pthreads, OpenMP-threads) on the CPU and threads in CUDA-block y-direction on the GPU. The inner loop then applies vectorization pragmas on the CPU or spwans threads in x-direction on the GPU. This is where we have to show some awareness of architectural differences: the spinor work type \nTST\n needs to be a scalar type on the GPU and a vector type on the CPU. Hence we declare the following types on GPU and CPU respectively\n\n\ntemplate\ntypename\n \nT\n,\nN\n \n\nstruct\n \nCPUSIMDComplex\n \n{\n\n    \nKokkos\n::\ncomplex\nT\n \n_data\n[\nN\n];\n\n    \nT\n \noperator\n()(\nint\n \nlane\n)\n \n{\n\n        \nreturn\n \n_data\n[\nlane\n];\n\n    \n}\n\n    \n...\n\n\n};\n\n\n\ntemplate\ntypename\n \nT\n,\nN\n \n\nstruct\n \nGPUSIMDComplex\n \n{\n\n    \nKokkos\n::\ncomplex\nT\n \n_data\n;\n\n    \nT\n \noperator\n()(\nint\n \nlane\n)\n \n{\n\n        \nreturn\n \n_data\n;\n\n    \n}\n\n    \n...\n\n\n};\n\n\n\n\n\nThe latter construct might look confusing first, because the access operator ignores the \nlane\n parameter. This is because the SIMT threading is implicit in Kokkos and each SIMT thread is holding it's own data \n_data\n. Nevertheless, it is useful to implement the access operator that way to preserve a common, portable style throughout the rest of the code.\n\n\nSpecialization for CPU\n\n\nIn theory, these two types are sufficient for ensuring proper vectorization on both CPU and GPU. In our experiments however, we found that neither Intel nor GNU compiler could vectorize the complex operations inside the spinors properly, leading to a very poor performance. This is not a problem of Kokkos itself, it is merely the inability of compilers to efficiently vectorized complex algebra. We therefore provided a template  specialization for the \nCPUSIMDComplex\n datatype which we implemented by explicitly using AVX512 intrinsics. For example, the datatype then becomes\n\n\ntemplate\n\n\nstruct\n \nCPUSIMDComplex\nfloat\n,\n8\n \n{\n\n    \nexplicit\n \nCPUSIMDComplex\nfloat\n,\n8\n()\n \n{}\n\n\n    \nunion\n \n{\n\n        \nKokkos\n::\ncomplex\nfloat\n \n_data\n[\n8\n];\n\n        \n__m512\n \n_vdata\n;\n\n    \n};\n\n    \n...\n\n\n};\n\n\n\n\n\nand, for example, the vectorized multiplication of two complex numbers\n\n\ntemplate\n \nKOKKOS_FORCEINLINE_FUNCTION\n\n\nvoid\n \nComplexCMadd\nfloat\n,\n8\n,\nCPUSIMDComplex\n,\nCPUSIMDComplex\n(\nCPUSIMDComplex\nfloat\n,\n8\n \nres\n,\n\n                                                         \nconst\n \nKokkos\n::\ncomplex\nfloat\n \na\n,\n\n                                                         \nconst\n \nCPUSIMDComplex\nfloat\n,\n8\n \nb\n)\n\n\n{\n\n  \n__m512\n \navec_re\n \n=\n \n_mm512_set1_ps\n(\n \na\n.\nreal\n()\n \n);\n\n  \n__m512\n \navec_im\n \n=\n \n_mm512_set1_ps\n(\n \na\n.\nimag\n()\n \n);\n\n\n  \n__m512\n \nsgnvec\n \n=\n \n_mm512_set_ps\n(\n \n1\n,\n-\n1\n,\n1\n,\n-\n1\n,\n1\n,\n-\n1\n,\n1\n,\n-\n1\n,\n1\n,\n-\n1\n,\n1\n,\n-\n1\n,\n1\n,\n-\n1\n,\n1\n,\n-\n1\n);\n\n  \n__m512\n \nperm_b\n \n=\n \n_mm512_mul_ps\n(\nsgnvec\n,\n_mm512_shuffle_ps\n(\nb\n.\n_vdata\n,\nb\n.\n_vdata\n,\n0xb1\n));\n\n\n  \nres\n.\n_vdata\n \n=\n \n_mm512_fmadd_ps\n(\n \navec_re\n,\n \nb\n.\n_vdata\n,\n \nres\n.\n_vdata\n);\n\n  \nres\n.\n_vdata\n \n=\n \n_mm512_fmadd_ps\n(\n \navec_im\n,\nperm_b\n,\n \nres\n.\n_vdata\n);\n\n\n}", 
            "title": "Kokkos Implementation"
        }, 
        {
            "location": "/case_studies/qcd/kokkos_implementation/#kokkos-implementation", 
            "text": "In this implementation, we will use the  Kokkos::View  type as our data container. Therefore, the  spinor and gaugefield classes  become  template typename   ST , int   nspin   class   CBSpinor   {  public :  \n     ...  private : \n     // dims are: site, color, spin \n     Kokkos :: View ST * [ 3 ][ nspin ]   data ;  };  template typename   GT   class   CBGaugeField   {  public : \n     ...  private : \n     // dims are: site, direction, color, color \n     gauge_container GT * [ 4 ][ 3 ][ 3 ]   data ;  };   Note that the site index dimension is a runtime dimension (denoted by  * ) whereas the other dimensions - color and spin - are fixed (denoted by  [const] ). Explicitly stating this is recommended by the kokkos developers because it should help the compiler to optimize the code.   In the  Wilsion operator class , all what we need to do is to insert the kokkos parallel dispatcher. Hence it becomes  template typename   GT ,   typename   ST ,   typename   TST  class   Dslash   { \n     public : \n     void   operator ( const   CBSpinor ST , 4   s_in , \n                   const   CBGaugeField GT   g_in , \n                   CBSpinor ST , 4   s_out , \n                   int   plus_minus )  \n     { \n         // Threaded loop over sites \n         Kokkos :: parallel_for ( num_sites ,   KOKKOS_LAMBDA ( int   i )   { \n             ... \n             }); \n     }  };", 
            "title": "Kokkos Implementation"
        }, 
        {
            "location": "/case_studies/qcd/kokkos_implementation/#ensuring-vectorization", 
            "text": "Vectorization in Kokkos is achieved by a two-level  nested parallelism , where the outer loop spawns threads (pthreads, OpenMP-threads) on the CPU and threads in CUDA-block y-direction on the GPU. The inner loop then applies vectorization pragmas on the CPU or spwans threads in x-direction on the GPU. This is where we have to show some awareness of architectural differences: the spinor work type  TST  needs to be a scalar type on the GPU and a vector type on the CPU. Hence we declare the following types on GPU and CPU respectively  template typename   T , N   struct   CPUSIMDComplex   { \n     Kokkos :: complex T   _data [ N ]; \n     T   operator ()( int   lane )   { \n         return   _data [ lane ]; \n     } \n     ...  };  template typename   T , N   struct   GPUSIMDComplex   { \n     Kokkos :: complex T   _data ; \n     T   operator ()( int   lane )   { \n         return   _data ; \n     } \n     ...  };   The latter construct might look confusing first, because the access operator ignores the  lane  parameter. This is because the SIMT threading is implicit in Kokkos and each SIMT thread is holding it's own data  _data . Nevertheless, it is useful to implement the access operator that way to preserve a common, portable style throughout the rest of the code.", 
            "title": "Ensuring Vectorization"
        }, 
        {
            "location": "/case_studies/qcd/kokkos_implementation/#specialization-for-cpu", 
            "text": "In theory, these two types are sufficient for ensuring proper vectorization on both CPU and GPU. In our experiments however, we found that neither Intel nor GNU compiler could vectorize the complex operations inside the spinors properly, leading to a very poor performance. This is not a problem of Kokkos itself, it is merely the inability of compilers to efficiently vectorized complex algebra. We therefore provided a template  specialization for the  CPUSIMDComplex  datatype which we implemented by explicitly using AVX512 intrinsics. For example, the datatype then becomes  template  struct   CPUSIMDComplex float , 8   { \n     explicit   CPUSIMDComplex float , 8 ()   {} \n\n     union   { \n         Kokkos :: complex float   _data [ 8 ]; \n         __m512   _vdata ; \n     }; \n     ...  };   and, for example, the vectorized multiplication of two complex numbers  template   KOKKOS_FORCEINLINE_FUNCTION  void   ComplexCMadd float , 8 , CPUSIMDComplex , CPUSIMDComplex ( CPUSIMDComplex float , 8   res , \n                                                          const   Kokkos :: complex float   a , \n                                                          const   CPUSIMDComplex float , 8   b )  { \n   __m512   avec_re   =   _mm512_set1_ps (   a . real ()   ); \n   __m512   avec_im   =   _mm512_set1_ps (   a . imag ()   ); \n\n   __m512   sgnvec   =   _mm512_set_ps (   1 , - 1 , 1 , - 1 , 1 , - 1 , 1 , - 1 , 1 , - 1 , 1 , - 1 , 1 , - 1 , 1 , - 1 ); \n   __m512   perm_b   =   _mm512_mul_ps ( sgnvec , _mm512_shuffle_ps ( b . _vdata , b . _vdata , 0xb1 )); \n\n   res . _vdata   =   _mm512_fmadd_ps (   avec_re ,   b . _vdata ,   res . _vdata ); \n   res . _vdata   =   _mm512_fmadd_ps (   avec_im , perm_b ,   res . _vdata );  }", 
            "title": "Specialization for CPU"
        }, 
        {
            "location": "/case_studies/nek/", 
            "text": "", 
            "title": "NekBone"
        }, 
        {
            "location": "/case_studies/md/", 
            "text": "", 
            "title": "MD"
        }, 
        {
            "location": "/demo/demo/", 
            "text": "Welcome to NERSC\n\n\nWelcome to the National Energy Research Scientific Computing Center, a high performance scientific computing center.\nThis document will guide you through the basics of using NERSC\u2019s supercomputers, storage systems, and services.\n\n\nWhat is NERSC?\n\n\nNERSC provides High Performance Computing and Storage facilities and support for research sponsored by, and of interest to, the U.S. Department of Energy Office of Science. NERSC has the unique programmatic role of supporting all six Office of Science program offices: Advanced Scientific Computing Research, Basic Energy Sciences, Biological and Environmental Research, Fusion Energy Sciences, High Energy Physics, and Nuclear Physics. Scientists who have been awarded research funding by any of the offices are eligible to apply for an allocation of NERSC time. Additional awards may be given to non-DOE funded project teams whose research is aligned with the Office of Science's mission. Allocations of time and storage are made by DOE.\n\n\nNERSC is a national center, organizationally part of Lawrence Berkeley National Laboratory in Berkeley, CA. NERSC staff and facilities are primarily located at Berkeley Lab's Shyh Wang Hall on the Berkeley Lab campus.\n\n\nExternal links\n\n\n\n\nOLCF\n\n\nALCF\n\n\nNERSC\n\n\n\n\nInternal links\n\n\n\n\nPortability definition\n\n\n\n\nTables:\n\n\n\n\n\n\n\n\nSystem Type\n\n\nCray XC40\n\n\n\n\n\n\n\n\n\n\nTheoretical Peak Performance (System)\n\n\n31.4 PFlops\n\n\n\n\n\n\nTheoretical Peak Performance (Haswell nodes)\n\n\n2.3 PFlops\n\n\n\n\n\n\nTheoretical Peak Performance (Xeon Phi nodes)\n\n\n29.1 PFlops\n\n\n\n\n\n\nCompute Nodes (Haswell)\n\n\n2,388\n\n\n\n\n\n\n\n\nInclude scripts/ source code\n\n\nThis site supports an include extension to Markdown.\n\n\nOne way to run a pure MPI job on Cori is\n\n\n#!/bin/bash -l\n\n\n#SBATCH -p debug\n\n\n#SBATCH -N 64\n\n\n#SBATCH -t 00:20:00\n\n\n#SBATCH -J my_job\n\n\n#SBATCH -L SCRATCH\n\n\n#SBATCH -C haswell\n\n\n\n# an extra -c 2 flag is optional for fully packed pure MPI\n\nsrun -n \n2048\n ./mycode.exe\n\n\n\n\n\n\nWarning\n\n\nThe \n-c\n and \n--cpu_bind=\n options for \nsrun\n are \nrequired\n for hybrid jobs or jobs which do not utilize all physical cores \n\n\n\n\nSome source code\n\n\nInstrumented C code to measure AI\n\n\n// Code must be built with appropriate paths for VTune include file (ittnotify.h) and library (-littnotify)\n\n\n#include\n \nittnotify.h\n\n\n\n__SSC_MARK\n(\n0x111\n);\n \n// start SDE tracing, note it uses 2 underscores\n\n\n__itt_resume\n();\n \n// start VTune, again use 2 underscores\n\n\n\nfor\n \n(\nk\n=\n0\n;\n \nk\nNTIMES\n;\n \nk\n++\n)\n \n{\n\n \n#pragma omp parallel for\n\n \nfor\n \n(\nj\n=\n0\n;\n \nj\nSTREAM_ARRAY_SIZE\n;\n \nj\n++\n)\n\n \na\n[\nj\n]\n \n=\n \nb\n[\nj\n]\n+\nscalar\n*\nc\n[\nj\n];\n\n\n}\n\n\n\n__itt_pause\n();\n \n// stop VTune\n\n\n__SSC_MARK\n(\n0x222\n);\n \n// stop SDE tracing\n\n\n\n\n\nAnd some totally unrelated python code\n\n\ndef\n \ncount_cross_connections\n(\ncounts\n):\n\n    \nCounts is a list of the number of nodes in each (non-zero) group\n\n    \nreturn\n \nsum\n(\n \nx\n[\n0\n]\n*\nx\n[\n1\n]\n \nfor\n \nx\n \nin\n \nitertools\n.\ncombinations\n(\ncounts\n,\n \n2\n)\n \n)\n\n\n\n\n\nLaTex support\n\n\n\\[\n\\frac{n!}{k!(n-k)!} = \\binom{n}{k}\n\\]\nfrom:\n\n\n$$\n\\frac{n!}{k!(n-k)!} = \\binom{n}{k}\n$$\n\n\n\n\nImages\n\n\n\n\nInline HTML\n\n\nThis is probably best avoided if possible, but it works.\n\n\n\n  \nDefinition list\n\n  \nIs something people use sometimes.\n\n\n  \nMarkdown in HTML\n\n  \nDoes *not* work **very** well. Use HTML \ntags\n.", 
            "title": "Demo"
        }, 
        {
            "location": "/demo/demo/#welcome-to-nersc", 
            "text": "Welcome to the National Energy Research Scientific Computing Center, a high performance scientific computing center.\nThis document will guide you through the basics of using NERSC\u2019s supercomputers, storage systems, and services.", 
            "title": "Welcome to NERSC"
        }, 
        {
            "location": "/demo/demo/#what-is-nersc", 
            "text": "NERSC provides High Performance Computing and Storage facilities and support for research sponsored by, and of interest to, the U.S. Department of Energy Office of Science. NERSC has the unique programmatic role of supporting all six Office of Science program offices: Advanced Scientific Computing Research, Basic Energy Sciences, Biological and Environmental Research, Fusion Energy Sciences, High Energy Physics, and Nuclear Physics. Scientists who have been awarded research funding by any of the offices are eligible to apply for an allocation of NERSC time. Additional awards may be given to non-DOE funded project teams whose research is aligned with the Office of Science's mission. Allocations of time and storage are made by DOE.  NERSC is a national center, organizationally part of Lawrence Berkeley National Laboratory in Berkeley, CA. NERSC staff and facilities are primarily located at Berkeley Lab's Shyh Wang Hall on the Berkeley Lab campus.", 
            "title": "What is NERSC?"
        }, 
        {
            "location": "/demo/demo/#external-links", 
            "text": "OLCF  ALCF  NERSC", 
            "title": "External links"
        }, 
        {
            "location": "/demo/demo/#internal-links", 
            "text": "Portability definition   Tables:     System Type  Cray XC40      Theoretical Peak Performance (System)  31.4 PFlops    Theoretical Peak Performance (Haswell nodes)  2.3 PFlops    Theoretical Peak Performance (Xeon Phi nodes)  29.1 PFlops    Compute Nodes (Haswell)  2,388", 
            "title": "Internal links"
        }, 
        {
            "location": "/demo/demo/#include-scripts-source-code", 
            "text": "This site supports an include extension to Markdown.  One way to run a pure MPI job on Cori is  #!/bin/bash -l  #SBATCH -p debug  #SBATCH -N 64  #SBATCH -t 00:20:00  #SBATCH -J my_job  #SBATCH -L SCRATCH  #SBATCH -C haswell  # an extra -c 2 flag is optional for fully packed pure MPI \nsrun -n  2048  ./mycode.exe   Warning  The  -c  and  --cpu_bind=  options for  srun  are  required  for hybrid jobs or jobs which do not utilize all physical cores", 
            "title": "Include scripts/ source code"
        }, 
        {
            "location": "/demo/demo/#some-source-code", 
            "text": "Instrumented C code to measure AI  // Code must be built with appropriate paths for VTune include file (ittnotify.h) and library (-littnotify)  #include   ittnotify.h  __SSC_MARK ( 0x111 );   // start SDE tracing, note it uses 2 underscores  __itt_resume ();   // start VTune, again use 2 underscores  for   ( k = 0 ;   k NTIMES ;   k ++ )   { \n  #pragma omp parallel for \n  for   ( j = 0 ;   j STREAM_ARRAY_SIZE ;   j ++ ) \n  a [ j ]   =   b [ j ] + scalar * c [ j ];  }  __itt_pause ();   // stop VTune  __SSC_MARK ( 0x222 );   // stop SDE tracing   And some totally unrelated python code  def   count_cross_connections ( counts ): \n     Counts is a list of the number of nodes in each (non-zero) group \n     return   sum (   x [ 0 ] * x [ 1 ]   for   x   in   itertools . combinations ( counts ,   2 )   )", 
            "title": "Some source code"
        }, 
        {
            "location": "/demo/demo/#latex-support", 
            "text": "\\[\n\\frac{n!}{k!(n-k)!} = \\binom{n}{k}\n\\] from:  $$\n\\frac{n!}{k!(n-k)!} = \\binom{n}{k}\n$$", 
            "title": "LaTex support"
        }, 
        {
            "location": "/demo/demo/#images", 
            "text": "", 
            "title": "Images"
        }, 
        {
            "location": "/demo/demo/#inline-html", 
            "text": "This is probably best avoided if possible, but it works.  \n   Definition list \n   Is something people use sometimes. \n\n   Markdown in HTML \n   Does *not* work **very** well. Use HTML  tags .", 
            "title": "Inline HTML"
        }
    ]
}